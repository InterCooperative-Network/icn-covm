cargo fmt -- --check
Diff in /home/matt/dev/nano-cvm/src/compiler/common.rs:34:
 /// Helper to find nested blocks within indented code
 pub fn find_block_end(lines: &[String], start_line: usize, base_indent: usize) -> usize {
     let mut end_line = start_line;
[31m-    
(B[m[32m+
(B[m     while end_line < lines.len() && get_indent(&lines[end_line]) > base_indent {
         end_line += 1;
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/common.rs:41:
[31m-    
(B[m[32m+
(B[m     end_line
 }
 
Diff in /home/matt/dev/nano-cvm/src/compiler/common.rs:46:
 pub fn collect_block_lines(lines: &[String], start_line: usize, base_indent: usize) -> Vec<String> {
     let end_line = find_block_end(lines, start_line, base_indent);
     lines[start_line..end_line].to_vec()
[31m-} 
(B[m[32m+}
(B[m[32m+
(B[mDiff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:1:
[32m+use super::{common, line_parser, CompilerError, SourcePosition};
(B[m use crate::vm::Op;
[31m-use super::{CompilerError, SourcePosition, common, line_parser};
(B[m 
 /// Parse a function definition block
[31m-pub fn parse_function_block(lines: &[String], current_line: &mut usize, pos: SourcePosition) -> Result<Op, CompilerError> {
(B[m[32m+pub fn parse_function_block(
(B[m[32m+    lines: &[String],
(B[m[32m+    current_line: &mut usize,
(B[m[32m+    pos: SourcePosition,
(B[m[32m+) -> Result<Op, CompilerError> {
(B[m     let line = &lines[*current_line];
[31m-    
(B[m[32m+
(B[m     // Expected format: def name(param1, param2):
     if !line.contains('(') || !line.contains(')') {
[31m-        return Err(CompilerError::InvalidFunctionFormat(line.to_string(), pos.line, pos.column));
(B[m[32m+        return Err(CompilerError::InvalidFunctionFormat(
(B[m[32m+            line.to_string(),
(B[m[32m+            pos.line,
(B[m[32m+            pos.column,
(B[m[32m+        ));
(B[m     }
[31m-    
(B[m[32m+
(B[m     // Extract name and parameters
     let name_params = parse_function_signature(line, pos)?;
     let name = name_params.0;
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:16:
     let params = name_params.1;
[31m-    
(B[m[32m+
(B[m     let current_indent = common::get_indent(line);
     *current_line += 1;
[31m-    
(B[m[32m+
(B[m     // Parse function body
     let body = line_parser::parse_block(lines, current_line, current_indent, pos)?;
[31m-    
(B[m[31m-    Ok(Op::Def {
(B[m[31m-        name,
(B[m[31m-        params,
(B[m[31m-        body,
(B[m[31m-    })
(B[m[32m+
(B[m[32m+    Ok(Op::Def { name, params, body })
(B[m }
 
 /// Helper function to parse function signature
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:32:
[31m-pub fn parse_function_signature(line: &str, pos: SourcePosition) -> Result<(String, Vec<String>), CompilerError> {
(B[m[32m+pub fn parse_function_signature(
(B[m[32m+    line: &str,
(B[m[32m+    pos: SourcePosition,
(B[m[32m+) -> Result<(String, Vec<String>), CompilerError> {
(B[m     // Format: def name(x, y):
     let parts: Vec<&str> = line.trim_end_matches(':').splitn(2, '(').collect();
     if parts.len() != 2 {
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:36:
[31m-        return Err(CompilerError::InvalidFunctionDefinition(line.to_string(), pos.line, pos.column));
(B[m[32m+        return Err(CompilerError::InvalidFunctionDefinition(
(B[m[32m+            line.to_string(),
(B[m[32m+            pos.line,
(B[m[32m+            pos.column,
(B[m[32m+        ));
(B[m     }
 
     let name_part = parts[0].trim();
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:40:
     if !name_part.starts_with("def ") {
[31m-        return Err(CompilerError::InvalidFunctionStart(line.to_string(), pos.line, pos.column));
(B[m[32m+        return Err(CompilerError::InvalidFunctionStart(
(B[m[32m+            line.to_string(),
(B[m[32m+            pos.line,
(B[m[32m+            pos.column,
(B[m[32m+        ));
(B[m     }
[31m-    
(B[m[32m+
(B[m     let name = name_part["def ".len()..].trim().to_string();
[31m-    
(B[m[32m+
(B[m     // Extract parameters
     let params_str = parts[1].trim_end_matches(')');
     let params: Vec<String> = params_str
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:57:
 #[cfg(test)]
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_function_block_parsing() {
         let source = vec![
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:67:
             "    add".to_string(),
             "    return".to_string(),
         ];
[31m-        
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let op = parse_function_block(&source, &mut current_line, pos).unwrap();
[31m-        
(B[m[32m+
(B[m         match op {
             Op::Def { name, params, body } => {
                 assert_eq!(name, "add");
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:79:
                 assert_eq!(params, vec!["x".to_string(), "y".to_string()]);
                 assert_eq!(body.len(), 4);
[31m-            },
(B[m[32m+            }
(B[m             _ => panic!("Expected Def operation"),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:85:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_function_without_params() {
         let source = vec![
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:90:
             "    push 42".to_string(),
             "    return".to_string(),
         ];
[31m-        
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let op = parse_function_block(&source, &mut current_line, pos).unwrap();
[31m-        
(B[m[32m+
(B[m         match op {
             Op::Def { name, params, body } => {
                 assert_eq!(name, "constant");
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:102:
                 assert_eq!(params.len(), 0);
                 assert_eq!(body.len(), 2);
[31m-            },
(B[m[32m+            }
(B[m             _ => panic!("Expected Def operation"),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:108:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_invalid_function_signature() {
[31m-        let source = vec![
(B[m[31m-            "def invalid".to_string(),
(B[m[31m-            "    push 1".to_string(),
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let source = vec!["def invalid".to_string(), "    push 1".to_string()];
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let result = parse_function_block(&source, &mut current_line, pos);
         assert!(result.is_err());
[31m-        
(B[m[32m+
(B[m         match result.unwrap_err() {
             CompilerError::InvalidFunctionFormat(_, line, _) => {
                 assert_eq!(line, 1);
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:125:
[31m-            },
(B[m[32m+            }
(B[m             err => panic!("Expected InvalidFunctionFormat error, got {:?}", err),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:129:
[31m-} 
(B[m[32m+}
(B[m[32m+
(B[mDiff in /home/matt/dev/nano-cvm/src/compiler/if_block.rs:1:
[32m+use super::{common, line_parser, CompilerError, SourcePosition};
(B[m use crate::vm::Op;
[31m-use super::{CompilerError, SourcePosition, common, line_parser};
(B[m 
 /// Parse an if statement block
[31m-pub fn parse_if_block(lines: &[String], current_line: &mut usize, pos: SourcePosition) -> Result<Op, CompilerError> {
(B[m[32m+pub fn parse_if_block(
(B[m[32m+    lines: &[String],
(B[m[32m+    current_line: &mut usize,
(B[m[32m+    pos: SourcePosition,
(B[m[32m+) -> Result<Op, CompilerError> {
(B[m     let mut condition = Vec::new();
     let mut then_block = Vec::new();
     let mut else_block = None;
Diff in /home/matt/dev/nano-cvm/src/compiler/if_block.rs:16:
 
     // Check for else block
     if *current_line < lines.len() && lines[*current_line].trim() == "else:" {
[31m-        let else_pos = SourcePosition::new(pos.line + *current_line, common::get_indent(&lines[*current_line]) + 1);
(B[m[32m+        let else_pos = SourcePosition::new(
(B[m[32m+            pos.line + *current_line,
(B[m[32m+            common::get_indent(&lines[*current_line]) + 1,
(B[m[32m+        );
(B[m         *current_line += 1;
[31m-        
(B[m[32m+
(B[m         let else_ops = line_parser::parse_block(lines, current_line, current_indent, else_pos)?;
         else_block = Some(else_ops);
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/if_block.rs:33:
 #[cfg(test)]
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_if_block_parsing() {
         let source = vec![
Diff in /home/matt/dev/nano-cvm/src/compiler/if_block.rs:44:
             "else:".to_string(),
             "    push 0".to_string(),
         ];
[31m-        
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let op = parse_if_block(&source, &mut current_line, pos).unwrap();
[31m-        
(B[m[32m+
(B[m         match op {
[31m-            Op::If { condition: _, then, else_ } => {
(B[m[32m+            Op::If {
(B[m[32m+                condition: _,
(B[m[32m+                then,
(B[m[32m+                else_,
(B[m[32m+            } => {
(B[m                 assert_eq!(then.len(), 3);
                 assert!(else_.is_some());
                 let else_block = else_.unwrap();
Diff in /home/matt/dev/nano-cvm/src/compiler/if_block.rs:58:
                 assert_eq!(else_block.len(), 1);
[31m-            },
(B[m[32m+            }
(B[m             _ => panic!("Expected If operation"),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/if_block.rs:63:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_nested_if_blocks() {
         let source = vec![
Diff in /home/matt/dev/nano-cvm/src/compiler/if_block.rs:74:
             "else:".to_string(),
             "    push 0".to_string(),
         ];
[31m-        
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let op = parse_if_block(&source, &mut current_line, pos).unwrap();
[31m-        
(B[m[32m+
(B[m         match op {
[31m-            Op::If { condition: _, then, else_ } => {
(B[m[32m+            Op::If {
(B[m[32m+                condition: _,
(B[m[32m+                then,
(B[m[32m+                else_,
(B[m[32m+            } => {
(B[m                 assert_eq!(then.len(), 2); // push 1 and nested if
                 assert!(else_.is_some());
[31m-                
(B[m[32m+
(B[m                 // Check nested if
                 match &then[1] {
[31m-                    Op::If { condition: _, then: nested_then, else_: nested_else } => {
(B[m[32m+                    Op::If {
(B[m[32m+                        condition: _,
(B[m[32m+                        then: nested_then,
(B[m[32m+                        else_: nested_else,
(B[m[32m+                    } => {
(B[m                         assert_eq!(nested_then.len(), 2);
                         assert!(nested_else.is_some());
[31m-                    },
(B[m[32m+                    }
(B[m                     _ => panic!("Expected nested If operation"),
                 }
[31m-            },
(B[m[32m+            }
(B[m             _ => panic!("Expected If operation"),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/if_block.rs:100:
[31m-} 
(B[m[32m+}
(B[m[32m+
(B[mDiff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:1:
[32m+use super::{common, CompilerError, SourcePosition};
(B[m use crate::vm::Op;
[31m-use super::{CompilerError, SourcePosition, common};
(B[m 
 /// Parse a single line of DSL code
 pub fn parse_line(line: &str, pos: SourcePosition) -> Result<Op, CompilerError> {
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:16:
 
     match command {
         "push" => {
[31m-            let num_str = parts.next().ok_or(CompilerError::MissingPushValue(pos.line, pos.column))?;
(B[m[31m-            let num = num_str.parse::<f64>()
(B[m[31m-                .map_err(|_| CompilerError::InvalidPushValue(
(B[m[31m-                    num_str.to_string(), 
(B[m[31m-                    pos.line, 
(B[m[31m-                    common::adjusted_position(pos, line, num_str).column
(B[m[31m-                ))?;
(B[m[32m+            let num_str = parts
(B[m[32m+                .next()
(B[m[32m+                .ok_or(CompilerError::MissingPushValue(pos.line, pos.column))?;
(B[m[32m+            let num = num_str.parse::<f64>().map_err(|_| {
(B[m[32m+                CompilerError::InvalidPushValue(
(B[m[32m+                    num_str.to_string(),
(B[m[32m+                    pos.line,
(B[m[32m+                    common::adjusted_position(pos, line, num_str).column,
(B[m[32m+                )
(B[m[32m+            })?;
(B[m             Ok(Op::Push(num))
         }
         "emit" => {
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:40:
             if parts.len() < 5 {
                 return Err(CompilerError::InvalidEmitEventFormat(pos.line, pos.column));
             }
[31m-            
(B[m[32m+
(B[m             let category = parts[1].trim().to_string();
             let message = parts[3].trim().to_string();
[31m-            
(B[m[32m+
(B[m             Ok(Op::EmitEvent { category, message })
         }
         "assertequalstack" => {
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:50:
[31m-            let depth_str = parts.next().ok_or(CompilerError::MissingAssertDepth(pos.line, pos.column))?;
(B[m[31m-            let depth = depth_str.parse::<usize>()
(B[m[31m-                .map_err(|_| CompilerError::InvalidAssertDepth(
(B[m[31m-                    depth_str.to_string(), 
(B[m[31m-                    pos.line, 
(B[m[31m-                    common::adjusted_position(pos, line, depth_str).column
(B[m[31m-                ))?;
(B[m[31m-            
(B[m[32m+            let depth_str = parts
(B[m[32m+                .next()
(B[m[32m+                .ok_or(CompilerError::MissingAssertDepth(pos.line, pos.column))?;
(B[m[32m+            let depth = depth_str.parse::<usize>().map_err(|_| {
(B[m[32m+                CompilerError::InvalidAssertDepth(
(B[m[32m+                    depth_str.to_string(),
(B[m[32m+                    pos.line,
(B[m[32m+                    common::adjusted_position(pos, line, depth_str).column,
(B[m[32m+                )
(B[m[32m+            })?;
(B[m[32m+
(B[m             if depth < 2 {
                 return Err(CompilerError::InsufficientAssertDepth(pos.line, pos.column));
             }
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:61:
[31m-            
(B[m[32m+
(B[m             Ok(Op::AssertEqualStack { depth })
         }
         "break" => Ok(Op::Break),
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:65:
         "continue" => Ok(Op::Continue),
         "load" => {
             let var_name = parts.next().ok_or(CompilerError::MissingVariable(
[31m-                "load".to_string(), 
(B[m[31m-                pos.line, 
(B[m[31m-                pos.column
(B[m[32m+                "load".to_string(),
(B[m[32m+                pos.line,
(B[m[32m+                pos.column,
(B[m             ))?;
             Ok(Op::Load(var_name.to_string()))
[31m-        },
(B[m[32m+        }
(B[m         "store" => {
             let var_name = parts.next().ok_or(CompilerError::MissingVariable(
[31m-                "store".to_string(), 
(B[m[31m-                pos.line, 
(B[m[31m-                pos.column
(B[m[32m+                "store".to_string(),
(B[m[32m+                pos.line,
(B[m[32m+                pos.column,
(B[m             ))?;
             Ok(Op::Store(var_name.to_string()))
[31m-        },
(B[m[32m+        }
(B[m         "add" => Ok(Op::Add),
         "sub" => Ok(Op::Sub),
         "mul" => Ok(Op::Mul),
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:97:
         "pop" => Ok(Op::Pop),
         "return" => Ok(Op::Return),
         "call" => {
[31m-            let fn_name = parts.next().ok_or(CompilerError::MissingFunctionName(pos.line, pos.column))?;
(B[m[32m+            let fn_name = parts
(B[m[32m+                .next()
(B[m[32m+                .ok_or(CompilerError::MissingFunctionName(pos.line, pos.column))?;
(B[m             Ok(Op::Call(fn_name.to_string()))
[31m-        },
(B[m[32m+        }
(B[m         "dumpstack" => Ok(Op::DumpStack),
         "dumpmemory" => Ok(Op::DumpMemory),
         "dumpstate" => Ok(Op::DumpState), // New debug/introspection opcode
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:106:
[31m-        _ => Err(CompilerError::UnknownCommand(command.to_string(), pos.line, pos.column)),
(B[m[32m+        _ => Err(CompilerError::UnknownCommand(
(B[m[32m+            command.to_string(),
(B[m[32m+            pos.line,
(B[m[32m+            pos.column,
(B[m[32m+        )),
(B[m     }
 }
 
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:110:
 /// Parse a series of lines as a block of code
[31m-pub fn parse_block(lines: &[String], start_line: &mut usize, base_indent: usize, pos: SourcePosition) -> Result<Vec<Op>, CompilerError> {
(B[m[32m+pub fn parse_block(
(B[m[32m+    lines: &[String],
(B[m[32m+    start_line: &mut usize,
(B[m[32m+    base_indent: usize,
(B[m[32m+    pos: SourcePosition,
(B[m[32m+) -> Result<Vec<Op>, CompilerError> {
(B[m     let mut block_ops = Vec::new();
 
     while *start_line < lines.len() {
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:115:
         let line = &lines[*start_line];
         let indent = common::get_indent(line);
[31m-        
(B[m[32m+
(B[m         // If we've dedented, we're done with this block
         if indent <= base_indent || line.trim().is_empty() {
             break;
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:121:
         }
[31m-        
(B[m[32m+
(B[m         let current_pos = SourcePosition::new(pos.line + *start_line, indent + 1);
[31m-        
(B[m[32m+
(B[m         // Detect and parse nested blocks
         if line.trim().ends_with(':') {
             let op = if line.trim() == "if:" {
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:135:
             } else if line.trim().starts_with("loop ") {
                 super::loop_block::parse_loop_block(lines, start_line, current_pos)?
             } else {
[31m-                return Err(CompilerError::UnknownBlockType(line.trim().to_string(), current_pos.line, current_pos.column));
(B[m[32m+                return Err(CompilerError::UnknownBlockType(
(B[m[32m+                    line.trim().to_string(),
(B[m[32m+                    current_pos.line,
(B[m[32m+                    current_pos.column,
(B[m[32m+                ));
(B[m             };
[31m-            
(B[m[32m+
(B[m             if !matches!(op, Op::Nop) {
                 block_ops.push(op);
             }
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:144:
[31m-            
(B[m[32m+
(B[m             // Don't increment start_line here since the block parser already did it
         } else {
             // Regular statements
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:152:
             *start_line += 1;
         }
     }
[31m-    
(B[m[32m+
(B[m     Ok(block_ops)
[31m-} 
(B[m[32m+}
(B[m[32m+
(B[mDiff in /home/matt/dev/nano-cvm/src/compiler/loop_block.rs:1:
[32m+use super::{common, line_parser, CompilerError, SourcePosition};
(B[m use crate::vm::Op;
[31m-use super::{CompilerError, SourcePosition, common, line_parser};
(B[m 
 /// Parse a loop statement block
[31m-pub fn parse_loop_block(lines: &[String], current_line: &mut usize, pos: SourcePosition) -> Result<Op, CompilerError> {
(B[m[32m+pub fn parse_loop_block(
(B[m[32m+    lines: &[String],
(B[m[32m+    current_line: &mut usize,
(B[m[32m+    pos: SourcePosition,
(B[m[32m+) -> Result<Op, CompilerError> {
(B[m     // Parse the "loop N:" line, extracting N
     let line = &lines[*current_line];
     let parts: Vec<&str> = line.trim().splitn(2, ' ').collect();
Diff in /home/matt/dev/nano-cvm/src/compiler/loop_block.rs:9:
     if parts.len() != 2 || !parts[0].eq_ignore_ascii_case("loop") {
[31m-        return Err(CompilerError::InvalidLoopFormat(line.trim().to_string(), pos.line, pos.column));
(B[m[32m+        return Err(CompilerError::InvalidLoopFormat(
(B[m[32m+            line.trim().to_string(),
(B[m[32m+            pos.line,
(B[m[32m+            pos.column,
(B[m[32m+        ));
(B[m     }
[31m-    
(B[m[32m+
(B[m     let count_str = parts[1].trim_end_matches(':');
[31m-    let count = count_str.parse::<usize>()
(B[m[31m-        .map_err(|_| CompilerError::InvalidLoopCount(
(B[m[31m-            count_str.to_string(), 
(B[m[31m-            pos.line, 
(B[m[31m-            common::adjusted_position(pos, line, count_str).column
(B[m[31m-        ))?;
(B[m[31m-    
(B[m[32m+    let count = count_str.parse::<usize>().map_err(|_| {
(B[m[32m+        CompilerError::InvalidLoopCount(
(B[m[32m+            count_str.to_string(),
(B[m[32m+            pos.line,
(B[m[32m+            common::adjusted_position(pos, line, count_str).column,
(B[m[32m+        )
(B[m[32m+    })?;
(B[m[32m+
(B[m     let current_indent = common::get_indent(line);
[31m-    
(B[m[32m+
(B[m     // Skip the "loop N:" line
     *current_line += 1;
[31m-    
(B[m[32m+
(B[m     // Parse the body
     let body = line_parser::parse_block(lines, current_line, current_indent, pos)?;
[31m-    
(B[m[32m+
(B[m     Ok(Op::Loop { count, body })
 }
 
Diff in /home/matt/dev/nano-cvm/src/compiler/loop_block.rs:32:
 #[cfg(test)]
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_loop_block_parsing() {
         let source = vec![
Diff in /home/matt/dev/nano-cvm/src/compiler/loop_block.rs:41:
             "    push 2".to_string(),
             "    add".to_string(),
         ];
[31m-        
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let op = parse_loop_block(&source, &mut current_line, pos).unwrap();
[31m-        
(B[m[32m+
(B[m         match op {
             Op::Loop { count, body } => {
                 assert_eq!(count, 5);
Diff in /home/matt/dev/nano-cvm/src/compiler/loop_block.rs:53:
                 assert_eq!(body.len(), 3);
[31m-            },
(B[m[32m+            }
(B[m             _ => panic!("Expected Loop operation"),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/loop_block.rs:58:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_nested_loop_blocks() {
         let source = vec![
Diff in /home/matt/dev/nano-cvm/src/compiler/loop_block.rs:65:
             "        push 2".to_string(),
             "        add".to_string(),
         ];
[31m-        
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let op = parse_loop_block(&source, &mut current_line, pos).unwrap();
[31m-        
(B[m[32m+
(B[m         match op {
             Op::Loop { count, body } => {
                 assert_eq!(count, 3);
Diff in /home/matt/dev/nano-cvm/src/compiler/loop_block.rs:77:
                 assert_eq!(body.len(), 2); // push 1 and nested loop
[31m-                
(B[m[32m+
(B[m                 // Check nested loop
                 match &body[1] {
[31m-                    Op::Loop { count: nested_count, body: nested_body } => {
(B[m[32m+                    Op::Loop {
(B[m[32m+                        count: nested_count,
(B[m[32m+                        body: nested_body,
(B[m[32m+                    } => {
(B[m                         assert_eq!(*nested_count, 2);
                         assert_eq!(nested_body.len(), 2);
[31m-                    },
(B[m[32m+                    }
(B[m                     _ => panic!("Expected nested Loop operation"),
                 }
[31m-            },
(B[m[32m+            }
(B[m             _ => panic!("Expected Loop operation"),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/loop_block.rs:91:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_invalid_loop_count() {
[31m-        let source = vec![
(B[m[31m-            "loop abc:".to_string(),
(B[m[31m-            "    push 1".to_string(),
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let source = vec!["loop abc:".to_string(), "    push 1".to_string()];
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let result = parse_loop_block(&source, &mut current_line, pos);
         assert!(result.is_err());
[31m-        
(B[m[32m+
(B[m         match result.unwrap_err() {
             CompilerError::InvalidLoopCount(_, line, _) => {
                 assert_eq!(line, 1);
Diff in /home/matt/dev/nano-cvm/src/compiler/loop_block.rs:108:
[31m-            },
(B[m[32m+            }
(B[m             err => panic!("Expected InvalidLoopCount error, got {:?}", err),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/loop_block.rs:112:
[31m-} 
(B[m[32m+}
(B[m[32m+
(B[mDiff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:1:
[32m+use super::{common, line_parser, CompilerError, SourcePosition};
(B[m use crate::vm::Op;
[31m-use super::{CompilerError, SourcePosition, common, line_parser};
(B[m 
 /// Parse a match statement block
[31m-pub fn parse_match_block(lines: &[String], current_line: &mut usize, pos: SourcePosition) -> Result<Op, CompilerError> {
(B[m[32m+pub fn parse_match_block(
(B[m[32m+    lines: &[String],
(B[m[32m+    current_line: &mut usize,
(B[m[32m+    pos: SourcePosition,
(B[m[32m+) -> Result<Op, CompilerError> {
(B[m     let mut value_ops = Vec::new();
     let mut cases = Vec::new();
     let mut default_ops = None;
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:9:
     let current_indent = common::get_indent(&lines[*current_line]);
[31m-    
(B[m[32m+
(B[m     // Skip the "match:" line
     *current_line += 1;
[31m-    
(B[m[32m+
(B[m     // Parse the body of the match statement
     while *current_line < lines.len() {
         let line = &lines[*current_line];
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:17:
         let indent = common::get_indent(line);
[31m-        
(B[m[32m+
(B[m         if indent <= current_indent {
             break;
         }
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:22:
[31m-        
(B[m[32m+
(B[m         let line_pos = SourcePosition::new(pos.line + *current_line, indent + 1);
[31m-        
(B[m[32m+
(B[m         if line.trim() == "value:" {
             *current_line += 1;
             // Parse the value block
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:28:
             let value_indent = indent;
             let value_pos = SourcePosition::new(line_pos.line + 1, indent + 1);
[31m-            
(B[m[32m+
(B[m             value_ops = line_parser::parse_block(lines, current_line, value_indent, value_pos)?;
         } else if line.trim().starts_with("case ") {
             // Parse case value
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:34:
             let case_line = line.trim();
             let case_value_str = case_line[5..].trim().trim_end_matches(':');
[31m-            let case_value = case_value_str.parse::<f64>()
(B[m[31m-                .map_err(|_| CompilerError::InvalidCaseValue(
(B[m[31m-                    case_value_str.to_string(), 
(B[m[31m-                    line_pos.line, 
(B[m[31m-                    common::adjusted_position(line_pos, line, case_value_str).column
(B[m[31m-                ))?;
(B[m[31m-            
(B[m[32m+            let case_value = case_value_str.parse::<f64>().map_err(|_| {
(B[m[32m+                CompilerError::InvalidCaseValue(
(B[m[32m+                    case_value_str.to_string(),
(B[m[32m+                    line_pos.line,
(B[m[32m+                    common::adjusted_position(line_pos, line, case_value_str).column,
(B[m[32m+                )
(B[m[32m+            })?;
(B[m[32m+
(B[m             let case_indent = indent;
             *current_line += 1;
[31m-            
(B[m[32m+
(B[m             // Parse case block
             let case_pos = SourcePosition::new(line_pos.line + 1, indent + 1);
             let case_ops = line_parser::parse_block(lines, current_line, case_indent, case_pos)?;
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:49:
[31m-            
(B[m[32m+
(B[m             cases.push((case_value, case_ops));
         } else if line.trim() == "default:" {
             *current_line += 1;
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:53:
             let default_indent = indent;
[31m-            
(B[m[32m+
(B[m             // Parse default block
             let default_pos = SourcePosition::new(line_pos.line + 1, indent + 1);
[31m-            let default_block = line_parser::parse_block(lines, current_line, default_indent, default_pos)?;
(B[m[31m-            
(B[m[32m+            let default_block =
(B[m[32m+                line_parser::parse_block(lines, current_line, default_indent, default_pos)?;
(B[m[32m+
(B[m             default_ops = Some(default_block);
         } else {
             // If not in a special block, assume it's part of the value
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:66:
             *current_line += 1;
         }
     }
[31m-    
(B[m[32m+
(B[m     if value_ops.is_empty() {
         return Err(CompilerError::MissingMatchValue(pos.line, pos.column));
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:73:
[31m-    
(B[m[32m+
(B[m     Ok(Op::Match {
         value: value_ops,
         cases,
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:81:
 #[cfg(test)]
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_match_block_parsing() {
         let source = vec![
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:95:
             "    default:".to_string(),
             "        push 0".to_string(),
         ];
[31m-        
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let op = parse_match_block(&source, &mut current_line, pos).unwrap();
[31m-        
(B[m[32m+
(B[m         match op {
[31m-            Op::Match { value, cases, default } => {
(B[m[32m+            Op::Match {
(B[m[32m+                value,
(B[m[32m+                cases,
(B[m[32m+                default,
(B[m[32m+            } => {
(B[m                 assert_eq!(value.len(), 1);
                 assert_eq!(cases.len(), 2);
                 assert!(default.is_some());
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:109:
[31m-                
(B[m[32m+
(B[m                 // Check case values
                 assert_eq!(cases[0].0, 1.0);
                 assert_eq!(cases[1].0, 2.0);
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:113:
[31m-                
(B[m[32m+
(B[m                 // Check case blocks
                 assert_eq!(cases[0].1.len(), 1);
                 assert_eq!(cases[1].1.len(), 1);
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:117:
[31m-                
(B[m[32m+
(B[m                 // Check default block
                 let default_block = default.unwrap();
                 assert_eq!(default_block.len(), 1);
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:121:
[31m-            },
(B[m[32m+            }
(B[m             _ => panic!("Expected Match operation"),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:125:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_match_without_default() {
         let source = vec![
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:134:
             "    case 2:".to_string(),
             "        push 20".to_string(),
         ];
[31m-        
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let op = parse_match_block(&source, &mut current_line, pos).unwrap();
[31m-        
(B[m[32m+
(B[m         match op {
[31m-            Op::Match { value, cases, default } => {
(B[m[32m+            Op::Match {
(B[m[32m+                value,
(B[m[32m+                cases,
(B[m[32m+                default,
(B[m[32m+            } => {
(B[m                 assert_eq!(value.len(), 1);
                 assert_eq!(cases.len(), 2);
                 assert!(default.is_none());
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:148:
[31m-            },
(B[m[32m+            }
(B[m             _ => panic!("Expected Match operation"),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:152:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_match_without_value_block() {
         let source = vec![
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:157:
             "    case 1:".to_string(),
             "        push 10".to_string(),
         ];
[31m-        
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let result = parse_match_block(&source, &mut current_line, pos);
         assert!(result.is_err());
[31m-        
(B[m[32m+
(B[m         match result.unwrap_err() {
             CompilerError::MissingMatchValue(line, _) => {
                 assert_eq!(line, 1);
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:170:
[31m-            },
(B[m[32m+            }
(B[m             err => panic!("Expected MissingMatchValue error, got {:?}", err),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:174:
[31m-} 
(B[m[32m+}
(B[m[32m+
(B[mDiff in /home/matt/dev/nano-cvm/src/compiler/mod.rs:3:
 
 // Sub-modules
 pub mod common;
[32m+pub mod function_block;
(B[m pub mod if_block;
[31m-pub mod while_block;
(B[m[32m+pub mod line_parser;
(B[m pub mod loop_block;
 pub mod match_block;
[31m-pub mod function_block;
(B[m[31m-pub mod line_parser;
(B[m[32m+pub mod while_block;
(B[m 
 // Re-export the parser functions
[31m-pub use line_parser::parse_line;
(B[m[32m+pub use function_block::parse_function_block;
(B[m pub use if_block::parse_if_block;
[31m-pub use while_block::parse_while_block;
(B[m[32m+pub use line_parser::parse_line;
(B[m pub use loop_block::parse_loop_block;
 pub use match_block::parse_match_block;
[31m-pub use function_block::parse_function_block;
(B[m[32m+pub use while_block::parse_while_block;
(B[m 
 // Add this at the end of the file, before the mod tests; line
 /// Standard library support
Diff in /home/matt/dev/nano-cvm/src/compiler/mod.rs:26:
 pub fn parse_dsl_with_stdlib(source: &str) -> Result<Vec<Op>, CompilerError> {
     // First load the standard library code
     let stdlib_code = stdlib::get_stdlib_code();
[31m-    
(B[m[32m+
(B[m     // Concatenate the standard library code with the user code
     let combined_code = format!("{}\n\n{}", stdlib_code, source);
[31m-    
(B[m[32m+
(B[m     // Parse the combined code
     parse_dsl(&combined_code)
 }
Diff in /home/matt/dev/nano-cvm/src/compiler/mod.rs:38:
 pub enum CompilerError {
     #[error("Unknown command: {0} at line {1}, column {2}")]
     UnknownCommand(String, usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Unknown block type: {0} at line {1}, column {2}")]
     UnknownBlockType(String, usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Invalid function definition: {0} at line {1}, column {2}")]
     InvalidFunctionDefinition(String, usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Invalid function definition format: {0} at line {1}, column {2}")]
     InvalidFunctionFormat(String, usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Function definition must start with 'def': {0} at line {1}, column {2}")]
     InvalidFunctionStart(String, usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Missing number for push at line {0}, column {1}")]
     MissingPushValue(usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Invalid number for push: {0} at line {1}, column {2}")]
     InvalidPushValue(String, usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Missing quotes for emit command at line {0}, column {1}")]
     MissingEmitQuotes(usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Invalid format for emitevent at line {0}, column {1}, expected: emitevent \"category\" \"message\"")]
     InvalidEmitEventFormat(usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Missing variable for {0} at line {1}, column {2}")]
     MissingVariable(String, usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Missing function name for call at line {0}, column {1}")]
     MissingFunctionName(usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Missing depth for assertequalstack at line {0}, column {1}")]
     MissingAssertDepth(usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Invalid depth for assertequalstack: {0} at line {1}, column {2}")]
     InvalidAssertDepth(String, usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Depth for assertequalstack must be at least 2 at line {0}, column {1}")]
     InsufficientAssertDepth(usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Invalid case value: {0} at line {1}, column {2}")]
     InvalidCaseValue(String, usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Match statement must have a value block at line {0}, column {1}")]
     MissingMatchValue(usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Invalid loop format: {0} at line {1}, column {2}")]
     InvalidLoopFormat(String, usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Invalid loop count: {0} at line {1}, column {2}")]
     InvalidLoopCount(String, usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Unexpected end of file while parsing block at line {0}")]
     UnexpectedEOF(usize),
[31m-    
(B[m[32m+
(B[m     #[error("Invalid indentation level at line {0}")]
     InvalidIndentation(usize),
 }
Diff in /home/matt/dev/nano-cvm/src/compiler/mod.rs:124:
         }
 
         let pos = SourcePosition::new(current_line + 1, common::get_indent(line) + 1);
[31m-        
(B[m[32m+
(B[m         let op = if line.trim().ends_with(':') {
             if line.trim() == "if:" {
                 parse_if_block(&lines, &mut current_line, pos)?
Diff in /home/matt/dev/nano-cvm/src/compiler/mod.rs:137:
             } else if line.trim().starts_with("loop ") {
                 parse_loop_block(&lines, &mut current_line, pos)?
             } else {
[31m-                return Err(CompilerError::UnknownBlockType(line.trim().to_string(), pos.line, pos.column));
(B[m[32m+                return Err(CompilerError::UnknownBlockType(
(B[m[32m+                    line.trim().to_string(),
(B[m[32m+                    pos.line,
(B[m[32m+                    pos.column,
(B[m[32m+                ));
(B[m             }
         } else {
             parse_line(line, pos)?
Diff in /home/matt/dev/nano-cvm/src/compiler/mod.rs:153:
 }
 
 #[cfg(test)]
[31m-mod tests; 
(B[m[32m+mod tests;
(B[m[32m+
(B[mDiff in /home/matt/dev/nano-cvm/src/compiler/stdlib.rs:87:
     or
     and
     return
[31m-"#.to_string()
(B[m[31m-} 
(B[m[32m+"#
(B[m[32m+    .to_string()
(B[m[32m+}
(B[m[32m+
(B[mDiff in /home/matt/dev/nano-cvm/src/compiler/tests.rs:1:
 // Tests for the compiler module
[31m-// Individual sub-modules have their own tests 
(B[m[32m+// Individual sub-modules have their own tests
(B[m[32m+
(B[mDiff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:1:
[32m+use super::{common, line_parser, CompilerError, SourcePosition};
(B[m use crate::vm::Op;
[31m-use super::{CompilerError, SourcePosition, common, line_parser};
(B[m 
 /// Parse a while statement block
[31m-pub fn parse_while_block(lines: &[String], current_line: &mut usize, pos: SourcePosition) -> Result<Op, CompilerError> {
(B[m[32m+pub fn parse_while_block(
(B[m[32m+    lines: &[String],
(B[m[32m+    current_line: &mut usize,
(B[m[32m+    pos: SourcePosition,
(B[m[32m+) -> Result<Op, CompilerError> {
(B[m     let mut condition = Vec::new();
     let mut body = Vec::new();
     let current_indent = common::get_indent(&lines[*current_line]);
Diff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:15:
     while *current_line < lines.len() {
         let line = &lines[*current_line];
         let indent = common::get_indent(line);
[31m-        
(B[m[32m+
(B[m         if indent <= current_indent {
             break;
         }
Diff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:25:
             has_explicit_condition = true;
             let condition_pos = SourcePosition::new(pos.line + *current_line, indent + 1);
             *current_line += 1;
[31m-            
(B[m[32m+
(B[m             // Parse condition block
             condition = line_parser::parse_block(lines, current_line, indent, condition_pos)?;
         } else if line.trim().ends_with(':') {
Diff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:32:
             // Handle nested block structures
             let nested_pos = SourcePosition::new(pos.line + *current_line, indent + 1);
[31m-            
(B[m[32m+
(B[m             if line.trim() == "if:" {
                 let nested_op = super::if_block::parse_if_block(lines, current_line, nested_pos)?;
                 body.push(nested_op);
Diff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:39:
                 let nested_op = parse_while_block(lines, current_line, nested_pos)?;
                 body.push(nested_op);
             } else if line.trim().starts_with("loop ") {
[31m-                let nested_op = super::loop_block::parse_loop_block(lines, current_line, nested_pos)?;
(B[m[32m+                let nested_op =
(B[m[32m+                    super::loop_block::parse_loop_block(lines, current_line, nested_pos)?;
(B[m                 body.push(nested_op);
             } else if line.trim() == "match:" {
[31m-                let nested_op = super::match_block::parse_match_block(lines, current_line, nested_pos)?;
(B[m[32m+                let nested_op =
(B[m[32m+                    super::match_block::parse_match_block(lines, current_line, nested_pos)?;
(B[m                 body.push(nested_op);
             } else {
[31m-                return Err(CompilerError::UnknownBlockType(line.trim().to_string(), nested_pos.line, nested_pos.column));
(B[m[32m+                return Err(CompilerError::UnknownBlockType(
(B[m[32m+                    line.trim().to_string(),
(B[m[32m+                    nested_pos.line,
(B[m[32m+                    nested_pos.column,
(B[m[32m+                ));
(B[m             }
         } else {
             // Regular statement in body
Diff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:64:
         condition = vec![body.remove(0)];
     }
 
[31m-    Ok(Op::While {
(B[m[31m-        condition,
(B[m[31m-        body,
(B[m[31m-    })
(B[m[32m+    Ok(Op::While { condition, body })
(B[m }
 
 #[cfg(test)]
Diff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:74:
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_while_block_parsing() {
         let source = vec![
Diff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:85:
             "    push 1".to_string(),
             "    sub".to_string(),
         ];
[31m-        
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let op = parse_while_block(&source, &mut current_line, pos).unwrap();
[31m-        
(B[m[32m+
(B[m         match op {
             Op::While { condition, body } => {
                 assert_eq!(condition.len(), 3);
Diff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:97:
                 assert_eq!(body.len(), 2);
[31m-            },
(B[m[32m+            }
(B[m             _ => panic!("Expected While operation"),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:102:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_nested_while_blocks() {
         let source = vec![
Diff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:110:
             "        push 1".to_string(),
             "        sub".to_string(),
         ];
[31m-        
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let op = parse_while_block(&source, &mut current_line, pos).unwrap();
[31m-        
(B[m[32m+
(B[m         match op {
             Op::While { condition, body } => {
                 assert_eq!(condition.len(), 1);
Diff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:122:
                 assert_eq!(body.len(), 1);
[31m-                
(B[m[32m+
(B[m                 // Check nested while
                 match &body[0] {
[31m-                    Op::While { condition: nested_condition, body: nested_body } => {
(B[m[32m+                    Op::While {
(B[m[32m+                        condition: nested_condition,
(B[m[32m+                        body: nested_body,
(B[m[32m+                    } => {
(B[m                         assert_eq!(nested_condition.len(), 1);
                         assert_eq!(nested_body.len(), 2);
[31m-                    },
(B[m[32m+                    }
(B[m                     _ => panic!("Expected nested While operation"),
                 }
[31m-            },
(B[m[32m+            }
(B[m             _ => panic!("Expected While operation"),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:136:
[31m-} 
(B[m[32m+}
(B[m[32m+
(B[mDiff in /home/matt/dev/nano-cvm/src/events.rs:1:
 use chrono::{DateTime, Utc};
[32m+use once_cell::sync::Lazy;
(B[m use serde::{Deserialize, Serialize};
 use std::fs::{File, OpenOptions};
 use std::io::{self, Write};
Diff in /home/matt/dev/nano-cvm/src/events.rs:5:
 use std::path::Path;
 use std::sync::Mutex;
[31m-use once_cell::sync::Lazy;
(B[m 
 #[derive(Debug, Clone, Serialize, Deserialize)]
 pub struct Event {
Diff in /home/matt/dev/nano-cvm/src/events.rs:11:
[31m-    pub level: String,     // "info", "warn", "error"
(B[m[31m-    pub tag: String,       // e.g., "emit", "stack", "memory", "governance"
(B[m[32m+    pub level: String, // "info", "warn", "error"
(B[m[32m+    pub tag: String,   // e.g., "emit", "stack", "memory", "governance"
(B[m     pub message: String,
     pub timestamp: String,
     #[serde(skip_serializing_if = "Option::is_none")]
Diff in /home/matt/dev/nano-cvm/src/events.rs:26:
 static LOG_FILE: Lazy<Mutex<Option<String>>> = Lazy::new(|| Mutex::new(None));
 
 impl Event {
[31m-    pub fn new<S1: Into<String>, S2: Into<String>, S3: Into<String>>(level: S1, tag: S2, message: S3) -> Self {
(B[m[32m+    pub fn new<S1: Into<String>, S2: Into<String>, S3: Into<String>>(
(B[m[32m+        level: S1,
(B[m[32m+        tag: S2,
(B[m[32m+        message: S3,
(B[m[32m+    ) -> Self {
(B[m         let now: DateTime<Utc> = Utc::now();
[31m-        
(B[m[32m+
(B[m         Self {
             level: level.into(),
             tag: tag.into(),
Diff in /home/matt/dev/nano-cvm/src/events.rs:37:
             data: None,
         }
     }
[31m-    
(B[m[32m+
(B[m     pub fn with_data(mut self, data: serde_json::Value) -> Self {
         self.data = Some(data);
         self
Diff in /home/matt/dev/nano-cvm/src/events.rs:44:
     }
[31m-    
(B[m[32m+
(B[m     pub fn info<S1: Into<String>, S2: Into<String>>(tag: S1, message: S2) -> Self {
         Self::new("info", tag, message)
     }
Diff in /home/matt/dev/nano-cvm/src/events.rs:49:
[31m-    
(B[m[32m+
(B[m     pub fn warn<S1: Into<String>, S2: Into<String>>(tag: S1, message: S2) -> Self {
         Self::new("warn", tag, message)
     }
Diff in /home/matt/dev/nano-cvm/src/events.rs:53:
[31m-    
(B[m[32m+
(B[m     pub fn error<S1: Into<String>, S2: Into<String>>(tag: S1, message: S2) -> Self {
         Self::new("error", tag, message)
     }
Diff in /home/matt/dev/nano-cvm/src/events.rs:57:
[31m-    
(B[m[32m+
(B[m     pub fn emit(&self) -> io::Result<()> {
         let format = LOG_FORMAT.lock().unwrap();
         let log_file = LOG_FILE.lock().unwrap().clone();
Diff in /home/matt/dev/nano-cvm/src/events.rs:61:
[31m-        
(B[m[32m+
(B[m         match *format {
             LogFormat::Pretty => self.emit_pretty(log_file),
             LogFormat::Json => self.emit_json(log_file),
Diff in /home/matt/dev/nano-cvm/src/events.rs:65:
         }
     }
[31m-    
(B[m[32m+
(B[m     fn emit_pretty(&self, log_file: Option<String>) -> io::Result<()> {
         let level_color = match self.level.as_str() {
[31m-            "info" => "\x1b[32m", // Green
(B[m[31m-            "warn" => "\x1b[33m", // Yellow
(B[m[32m+            "info" => "\x1b[32m",  // Green
(B[m[32m+            "warn" => "\x1b[33m",  // Yellow
(B[m             "error" => "\x1b[31m", // Red
[31m-            _ => "\x1b[0m",       // Default
(B[m[32m+            _ => "\x1b[0m",        // Default
(B[m         };
[31m-        
(B[m[32m+
(B[m         let pretty_line = format!(
[31m-            "{}{} [{}] [{}] {}\x1b[0m", 
(B[m[32m+            "{}{} [{}] [{}] {}\x1b[0m",
(B[m             level_color,
[31m-            self.timestamp.split('T').nth(1).unwrap_or(&self.timestamp).split('.').next().unwrap_or(""),
(B[m[31m-            self.level.to_uppercase(), 
(B[m[32m+            self.timestamp
(B[m[32m+                .split('T')
(B[m[32m+                .nth(1)
(B[m[32m+                .unwrap_or(&self.timestamp)
(B[m[32m+                .split('.')
(B[m[32m+                .next()
(B[m[32m+                .unwrap_or(""),
(B[m[32m+            self.level.to_uppercase(),
(B[m             self.tag,
             self.message
         );
Diff in /home/matt/dev/nano-cvm/src/events.rs:84:
[31m-        
(B[m[32m+
(B[m         // Always print to stdout
         println!("{}", pretty_line);
[31m-        
(B[m[32m+
(B[m         // If log file is specified, write to it
         if let Some(file_path) = log_file {
             let plain_line = format!(
Diff in /home/matt/dev/nano-cvm/src/events.rs:91:
[31m-                "{} [{}] [{}] {}", 
(B[m[31m-                self.timestamp, 
(B[m[31m-                self.level.to_uppercase(), 
(B[m[32m+                "{} [{}] [{}] {}",
(B[m[32m+                self.timestamp,
(B[m[32m+                self.level.to_uppercase(),
(B[m                 self.tag,
                 self.message
             );
Diff in /home/matt/dev/nano-cvm/src/events.rs:97:
[31m-            
(B[m[32m+
(B[m             append_to_file(&file_path, &plain_line)?;
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     fn emit_json(&self, log_file: Option<String>) -> io::Result<()> {
         let json = serde_json::to_string(&self).unwrap();
[31m-        
(B[m[32m+
(B[m         // Always print to stdout
         println!("{}", json);
[31m-        
(B[m[32m+
(B[m         // If log file is specified, write to it
         if let Some(file_path) = log_file {
             append_to_file(&file_path, &json)?;
Diff in /home/matt/dev/nano-cvm/src/events.rs:113:
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /home/matt/dev/nano-cvm/src/events.rs:128:
 
 fn append_to_file(file_path: &str, content: &str) -> io::Result<()> {
     let path = Path::new(file_path);
[31m-    
(B[m[32m+
(B[m     // Create parent directories if they don't exist
     if let Some(parent) = path.parent() {
         if !parent.exists() {
Diff in /home/matt/dev/nano-cvm/src/events.rs:135:
             std::fs::create_dir_all(parent)?;
         }
     }
[31m-    
(B[m[32m+
(B[m     // Open file with append mode
[31m-    let mut file = OpenOptions::new()
(B[m[31m-        .create(true)
(B[m[31m-        .append(true)
(B[m[31m-        .open(path)?;
(B[m[31m-    
(B[m[32m+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
(B[m[32m+
(B[m     // Write content with newline
     writeln!(file, "{}", content)?;
[31m-    
(B[m[32m+
(B[m     Ok(())
[31m-} 
(B[m[32m+}
(B[m[32m+
(B[mDiff in /home/matt/dev/nano-cvm/src/lib.rs:1:
[31m-pub mod vm;
(B[m pub mod compiler;
 pub mod events;
[31m-pub use vm::{Op, VM, VMError};
(B[m[32m+pub mod vm;
(B[m pub use compiler::{parse_dsl, parse_dsl_with_stdlib, CompilerError, SourcePosition};
[31m-pub use events::{Event, LogFormat, set_log_format, set_log_file}; 
(B[m[32m+pub use events::{set_log_file, set_log_format, Event, LogFormat};
(B[m[32m+pub use vm::{Op, VMError, VM};
(B[m[32m+
(B[mDiff in /home/matt/dev/nano-cvm/src/vm.rs:1:
[32m+use crate::events::Event;
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 use thiserror::Error;
Diff in /home/matt/dev/nano-cvm/src/vm.rs:4:
[31m-use crate::events::Event;
(B[m 
 #[derive(Debug, Error, Clone, PartialEq)]
 pub enum VMError {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:8:
     #[error("Stack underflow in {op}: needed {needed}, found {found}")]
[31m-    StackUnderflow { op: String, needed: usize, found: usize },
(B[m[31m-    
(B[m[32m+    StackUnderflow {
(B[m[32m+        op: String,
(B[m[32m+        needed: usize,
(B[m[32m+        found: usize,
(B[m[32m+    },
(B[m[32m+
(B[m     #[error("Division by zero")]
     DivisionByZero,
[31m-    
(B[m[32m+
(B[m     #[error("Variable not found: {0}")]
     VariableNotFound(String),
[31m-    
(B[m[32m+
(B[m     #[error("Function not found: {0}")]
     FunctionNotFound(String),
[31m-    
(B[m[32m+
(B[m     #[error("Maximum recursion depth exceeded")]
     MaxRecursionDepth,
[31m-    
(B[m[32m+
(B[m     #[error("Invalid condition: {0}")]
     InvalidCondition(String),
[31m-    
(B[m[32m+
(B[m     #[error("Assertion failed: expected {expected}, found {found}")]
     AssertionFailed { expected: f64, found: f64 },
[31m-    
(B[m[32m+
(B[m     #[error("IO error: {0}")]
     IOError(String),
[31m-    
(B[m[32m+
(B[m     #[error("REPL error: {0}")]
     ReplError(String),
[31m-    
(B[m[32m+
(B[m     #[error("Parameter error: {0}")]
     ParameterError(String),
 }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:46:
     Mod,
     Store(String),
     Load(String),
[31m-    If { condition: Vec<Op>, then: Vec<Op>, else_: Option<Vec<Op>> },
(B[m[31m-    Loop { count: usize, body: Vec<Op> },
(B[m[31m-    While { condition: Vec<Op>, body: Vec<Op> },
(B[m[32m+    If {
(B[m[32m+        condition: Vec<Op>,
(B[m[32m+        then: Vec<Op>,
(B[m[32m+        else_: Option<Vec<Op>>,
(B[m[32m+    },
(B[m[32m+    Loop {
(B[m[32m+        count: usize,
(B[m[32m+        body: Vec<Op>,
(B[m[32m+    },
(B[m[32m+    While {
(B[m[32m+        condition: Vec<Op>,
(B[m[32m+        body: Vec<Op>,
(B[m[32m+    },
(B[m     Emit(String),
     Negate,
     AssertTop(f64),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:55:
     DumpStack,
     DumpMemory,
[31m-    AssertMemory { key: String, expected: f64 },
(B[m[32m+    AssertMemory {
(B[m[32m+        key: String,
(B[m[32m+        expected: f64,
(B[m[32m+    },
(B[m     Pop,
     Eq,
     Gt,
Diff in /home/matt/dev/nano-cvm/src/vm.rs:65:
     Dup,
     Swap,
     Over,
[31m-    Def { name: String, params: Vec<String>, body: Vec<Op> },
(B[m[32m+    Def {
(B[m[32m+        name: String,
(B[m[32m+        params: Vec<String>,
(B[m[32m+        body: Vec<Op>,
(B[m[32m+    },
(B[m     Call(String),
     Return,
     Nop,
Diff in /home/matt/dev/nano-cvm/src/vm.rs:72:
     // New governance-inspired opcodes
[31m-    Match { value: Vec<Op>, cases: Vec<(f64, Vec<Op>)>, default: Option<Vec<Op>> },
(B[m[32m+    Match {
(B[m[32m+        value: Vec<Op>,
(B[m[32m+        cases: Vec<(f64, Vec<Op>)>,
(B[m[32m+        default: Option<Vec<Op>>,
(B[m[32m+    },
(B[m     Break,
     Continue,
[31m-    EmitEvent { category: String, message: String },
(B[m[31m-    AssertEqualStack { depth: usize },
(B[m[32m+    EmitEvent {
(B[m[32m+        category: String,
(B[m[32m+        message: String,
(B[m[32m+    },
(B[m[32m+    AssertEqualStack {
(B[m[32m+        depth: usize,
(B[m[32m+    },
(B[m     // Debug/introspection opcode
     DumpState,
 }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:137:
                     // For non-numeric strings, we'll store the length as a numeric value
                     // This allows parameters to be used in the stack machine
                     self.memory.insert(key.clone(), value.len() as f64);
[31m-                    
(B[m[32m+
(B[m                     // Also log this for debugging
                     let event = Event::info(
[31m-                        "params", 
(B[m[31m-                        &format!("Parameter '{}' is not numeric, storing length {}", key, value.len())
(B[m[32m+                        "params",
(B[m[32m+                        &format!(
(B[m[32m+                            "Parameter '{}' is not numeric, storing length {}",
(B[m[32m+                            key,
(B[m[32m+                            value.len()
(B[m[32m+                        ),
(B[m                     );
                     event.emit().map_err(|e| VMError::IOError(e.to_string()))?;
                 }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:159:
 
     // Helper for stack operations that need to pop one value
     fn pop_one(&mut self, op_name: &str) -> Result<f64, VMError> {
[31m-        self.stack.pop().ok_or_else(|| VMError::StackUnderflow { 
(B[m[31m-            op: op_name.to_string(), 
(B[m[31m-            needed: 1, 
(B[m[31m-            found: 0 
(B[m[32m+        self.stack.pop().ok_or_else(|| VMError::StackUnderflow {
(B[m[32m+            op: op_name.to_string(),
(B[m[32m+            needed: 1,
(B[m[32m+            found: 0,
(B[m         })
     }
 
Diff in /home/matt/dev/nano-cvm/src/vm.rs:169:
     // Helper for stack operations that need to pop two values
     fn pop_two(&mut self, op_name: &str) -> Result<(f64, f64), VMError> {
         if self.stack.len() < 2 {
[31m-            return Err(VMError::StackUnderflow { 
(B[m[31m-                op: op_name.to_string(), 
(B[m[31m-                needed: 2, 
(B[m[31m-                found: self.stack.len() 
(B[m[32m+            return Err(VMError::StackUnderflow {
(B[m[32m+                op: op_name.to_string(),
(B[m[32m+                needed: 2,
(B[m[32m+                found: self.stack.len(),
(B[m             });
         }
         let b = self.stack.pop().unwrap();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:191:
             if self.loop_control != LoopControl::None {
                 break;
             }
[31m-            
(B[m[32m+
(B[m             let op = &ops[pc];
             match op {
                 Op::Push(value) => {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:201:
                     self.pop_one("Pop")?;
                 }
                 Op::Dup => {
[31m-                    let value = self.stack.last().ok_or_else(|| VMError::StackUnderflow { 
(B[m[31m-                        op: "Dup".to_string(), 
(B[m[31m-                        needed: 1, 
(B[m[31m-                        found: 0 
(B[m[32m+                    let value = self.stack.last().ok_or_else(|| VMError::StackUnderflow {
(B[m[32m+                        op: "Dup".to_string(),
(B[m[32m+                        needed: 1,
(B[m[32m+                        found: 0,
(B[m                     })?;
                     self.stack.push(*value);
                 }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:211:
                 Op::Swap => {
                     if self.stack.len() < 2 {
[31m-                        return Err(VMError::StackUnderflow { 
(B[m[31m-                            op: "Swap".to_string(), 
(B[m[31m-                            needed: 2, 
(B[m[31m-                            found: self.stack.len()
(B[m[32m+                        return Err(VMError::StackUnderflow {
(B[m[32m+                            op: "Swap".to_string(),
(B[m[32m+                            needed: 2,
(B[m[32m+                            found: self.stack.len(),
(B[m                         });
                     }
                     let len = self.stack.len();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:221:
                 }
                 Op::Over => {
                     if self.stack.len() < 2 {
[31m-                        return Err(VMError::StackUnderflow { 
(B[m[31m-                            op: "Over".to_string(), 
(B[m[31m-                            needed: 2, 
(B[m[31m-                            found: self.stack.len()
(B[m[32m+                        return Err(VMError::StackUnderflow {
(B[m[32m+                            op: "Over".to_string(),
(B[m[32m+                            needed: 2,
(B[m[32m+                            found: self.stack.len(),
(B[m                         });
                     }
                     let value = self.stack[self.stack.len() - 2];
Diff in /home/matt/dev/nano-cvm/src/vm.rs:262:
                 }
                 Op::Eq => {
                     let (a, b) = self.pop_two("Eq")?;
[31m-                    self.stack.push(if (a - b).abs() < f64::EPSILON { 0.0 } else { 1.0 });
(B[m[32m+                    self.stack.push(if (a - b).abs() < f64::EPSILON {
(B[m[32m+                        0.0
(B[m[32m+                    } else {
(B[m[32m+                        1.0
(B[m[32m+                    });
(B[m                 }
                 Op::Lt => {
                     let (a, b) = self.pop_two("Lt")?;
Diff in /home/matt/dev/nano-cvm/src/vm.rs:278:
                 }
                 Op::And => {
                     let (a, b) = self.pop_two("And")?;
[31m-                    self.stack.push(if a != 0.0 && b != 0.0 { 1.0 } else { 0.0 });
(B[m[32m+                    self.stack
(B[m[32m+                        .push(if a != 0.0 && b != 0.0 { 1.0 } else { 0.0 });
(B[m                 }
                 Op::Or => {
                     let (a, b) = self.pop_two("Or")?;
Diff in /home/matt/dev/nano-cvm/src/vm.rs:285:
[31m-                    self.stack.push(if a != 0.0 || b != 0.0 { 1.0 } else { 0.0 });
(B[m[32m+                    self.stack
(B[m[32m+                        .push(if a != 0.0 || b != 0.0 { 1.0 } else { 0.0 });
(B[m                 }
                 Op::Store(key) => {
                     let value = self.pop_one("Store")?;
Diff in /home/matt/dev/nano-cvm/src/vm.rs:289:
[31m-                    
(B[m[32m+
(B[m                     // We need to store in the current function's memory if we're in a function call
                     if !self.call_frames.is_empty() {
                         // Store in the current call frame
Diff in /home/matt/dev/nano-cvm/src/vm.rs:293:
[31m-                        self.call_frames.last_mut().unwrap().memory.insert(key.clone(), value);
(B[m[32m+                        self.call_frames
(B[m[32m+                            .last_mut()
(B[m[32m+                            .unwrap()
(B[m[32m+                            .memory
(B[m[32m+                            .insert(key.clone(), value);
(B[m                     } else {
                         // Otherwise store in global memory
                         self.memory.insert(key.clone(), value);
Diff in /home/matt/dev/nano-cvm/src/vm.rs:304:
                             *value
                         } else {
                             // If not found in function memory, check global memory
[31m-                            *self.memory.get(key).ok_or_else(|| VMError::VariableNotFound(key.clone()))?
(B[m[32m+                            *self
(B[m[32m+                                .memory
(B[m[32m+                                .get(key)
(B[m[32m+                                .ok_or_else(|| VMError::VariableNotFound(key.clone()))?
(B[m                         }
                     } else {
                         // If not in a function, just use global memory
Diff in /home/matt/dev/nano-cvm/src/vm.rs:311:
[31m-                        *self.memory.get(key).ok_or_else(|| VMError::VariableNotFound(key.clone()))?
(B[m[32m+                        *self
(B[m[32m+                            .memory
(B[m[32m+                            .get(key)
(B[m[32m+                            .ok_or_else(|| VMError::VariableNotFound(key.clone()))?
(B[m                     };
[31m-                    
(B[m[32m+
(B[m                     self.stack.push(value);
                 }
                 Op::DumpStack => {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:334:
                     event.emit().map_err(|e| VMError::IOError(e.to_string()))?;
                 }
                 Op::Def { name, params, body } => {
[31m-                    self.functions.insert(name.clone(), (params.clone(), body.clone()));
(B[m[32m+                    self.functions
(B[m[32m+                        .insert(name.clone(), (params.clone(), body.clone()));
(B[m                 }
[31m-                
(B[m[32m+
(B[m                 Op::Loop { count, body } => {
                     for _i in 0..*count {
                         self.execute_inner(body)?;
Diff in /home/matt/dev/nano-cvm/src/vm.rs:343:
[31m-                        
(B[m[32m+
(B[m                         // Handle loop control flow
                         match self.loop_control {
                             LoopControl::Break => {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:347:
                                 self.loop_control = LoopControl::None;
                                 break;
[31m-                            },
(B[m[32m+                            }
(B[m                             LoopControl::Continue => {
                                 self.loop_control = LoopControl::None;
                                 continue;
Diff in /home/matt/dev/nano-cvm/src/vm.rs:353:
[31m-                            },
(B[m[32m+                            }
(B[m                             LoopControl::None => {}
                         }
                     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:357:
                 }
[31m-                
(B[m[32m+
(B[m                 Op::While { condition, body } => {
                     if condition.is_empty() {
                         return Err(VMError::InvalidCondition(
Diff in /home/matt/dev/nano-cvm/src/vm.rs:362:
[31m-                            "While condition block cannot be empty".to_string()
(B[m[32m+                            "While condition block cannot be empty".to_string(),
(B[m                         ));
                     }
 
Diff in /home/matt/dev/nano-cvm/src/vm.rs:366:
                     loop {
                         // Execute the condition code
                         self.execute_inner(condition)?;
[31m-                        
(B[m[32m+
(B[m                         // Get the result of the condition
                         let cond = self.pop_one("While condition")?;
[31m-                        
(B[m[32m+
(B[m                         // If condition is true (0.0), execute the body
                         // If condition is false (non-zero), exit the loop
                         if cond != 0.0 {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:376:
                             break;
                         }
[31m-                        
(B[m[32m+
(B[m                         // Execute the body code
                         self.execute_inner(body)?;
[31m-                        
(B[m[32m+
(B[m                         // Handle loop control flow
                         match self.loop_control {
                             LoopControl::Break => {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:385:
                                 self.loop_control = LoopControl::None;
                                 break;
[31m-                            },
(B[m[32m+                            }
(B[m                             LoopControl::Continue => {
                                 self.loop_control = LoopControl::None;
                                 continue;
Diff in /home/matt/dev/nano-cvm/src/vm.rs:391:
[31m-                            },
(B[m[32m+                            }
(B[m                             LoopControl::None => {}
                         }
                     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:395:
                 }
[31m-                
(B[m[32m+
(B[m                 Op::Break => {
                     self.loop_control = LoopControl::Break;
                 }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:400:
[31m-                
(B[m[32m+
(B[m                 Op::Continue => {
                     self.loop_control = LoopControl::Continue;
                 }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:404:
[31m-                
(B[m[32m+
(B[m                 Op::EmitEvent { category, message } => {
                     let event = Event::info(category.as_str(), message.as_str());
                     event.emit().map_err(|e| VMError::IOError(e.to_string()))?;
Diff in /home/matt/dev/nano-cvm/src/vm.rs:408:
                 }
[31m-                
(B[m[32m+
(B[m                 Op::AssertEqualStack { depth } => {
                     if self.stack.len() < *depth {
                         return Err(VMError::StackUnderflow {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:415:
                             found: self.stack.len(),
                         });
                     }
[31m-                    
(B[m[32m+
(B[m                     let top_value = self.stack[self.stack.len() - 1];
                     for i in 1..*depth {
[31m-                        if (self.stack[self.stack.len() - 1 - i] - top_value).abs() >= f64::EPSILON {
(B[m[32m+                        if (self.stack[self.stack.len() - 1 - i] - top_value).abs() >= f64::EPSILON
(B[m[32m+                        {
(B[m                             return Err(VMError::AssertionFailed {
                                 expected: top_value,
                                 found: self.stack[self.stack.len() - 1 - i],
Diff in /home/matt/dev/nano-cvm/src/vm.rs:427:
                     }
                 }
 
[31m-                Op::If { condition, then, else_ } => {
(B[m[31m-                    // Get condition value 
(B[m[32m+                Op::If {
(B[m[32m+                    condition,
(B[m[32m+                    then,
(B[m[32m+                    else_,
(B[m[32m+                } => {
(B[m[32m+                    // Get condition value
(B[m                     let condition_value = if condition.is_empty() {
                         // If condition is empty, use the value already on the stack
                         if self.stack.is_empty() {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:435:
[31m-                            return Err(VMError::StackUnderflow { 
(B[m[31m-                                op: "If".to_string(), 
(B[m[31m-                                needed: 1, 
(B[m[31m-                                found: 0 
(B[m[32m+                            return Err(VMError::StackUnderflow {
(B[m[32m+                                op: "If".to_string(),
(B[m[32m+                                needed: 1,
(B[m[32m+                                found: 0,
(B[m                             });
                         }
                         self.pop_one("If condition")?
Diff in /home/matt/dev/nano-cvm/src/vm.rs:442:
                     } else {
                         // Save the stack size before executing the condition
                         let stack_size_before = self.stack.len();
[31m-                        
(B[m[32m+
(B[m                         // Execute the condition operations
                         self.execute_inner(condition)?;
[31m-                        
(B[m[32m+
(B[m                         // Make sure the stack has at least one more value than before
                         if self.stack.len() <= stack_size_before {
                             return Err(VMError::InvalidCondition(
Diff in /home/matt/dev/nano-cvm/src/vm.rs:452:
[31m-                                "Condition block did not leave a value on the stack".to_string()
(B[m[32m+                                "Condition block did not leave a value on the stack".to_string(),
(B[m                             ));
                         }
[31m-                        
(B[m[32m+
(B[m                         // Get the top value from the stack
                         self.pop_one("If condition result")?
                     };
Diff in /home/matt/dev/nano-cvm/src/vm.rs:468:
                         self.stack.push(condition_value);
                     }
                 }
[31m-                
(B[m[32m+
(B[m                 Op::Negate => {
                     let value = self.pop_one("Negate")?;
                     self.stack.push(-value);
Diff in /home/matt/dev/nano-cvm/src/vm.rs:475:
                 }
[31m-                
(B[m[32m+
(B[m                 Op::Call(name) => {
[31m-                    let (params, body) = self.functions.get(name)
(B[m[32m+                    let (params, body) = self
(B[m[32m+                        .functions
(B[m[32m+                        .get(name)
(B[m                         .ok_or_else(|| VMError::FunctionNotFound(name.clone()))?
                         .clone();
[31m-                    
(B[m[32m+
(B[m                     // Create a new call frame for function execution
                     let mut frame = CallFrame {
                         memory: HashMap::new(),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:485:
                         return_value: None,
                     };
[31m-                    
(B[m[32m+
(B[m                     // If there are named parameters, pop values for them from the stack
                     if !params.is_empty() {
                         if self.stack.len() < params.len() {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:494:
                                 found: self.stack.len(),
                             });
                         }
[31m-                        
(B[m[32m+
(B[m                         // Pop values from the stack in reverse order (last parameter first)
                         let mut param_values = Vec::with_capacity(params.len());
                         for _ in 0..params.len() {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:501:
                             param_values.push(self.stack.pop().unwrap());
                         }
                         param_values.reverse(); // Reverse to match parameter order
[31m-                        
(B[m[32m+
(B[m                         // Store parameters in the function's memory
                         for (param, value) in params.iter().zip(param_values.iter()) {
                             frame.memory.insert(param.clone(), *value);
Diff in /home/matt/dev/nano-cvm/src/vm.rs:508:
                         }
                     }
[31m-                    
(B[m[32m+
(B[m                     // Push the call frame onto the call stack
                     self.call_frames.push(frame);
[31m-                    
(B[m[32m+
(B[m                     // Increment recursion depth
                     self.recursion_depth += 1;
[31m-                    
(B[m[32m+
(B[m                     // Execute the function body
                     self.execute_inner(&body)?;
[31m-                    
(B[m[32m+
(B[m                     // Decrement recursion depth
                     self.recursion_depth -= 1;
[31m-                    
(B[m[32m+
(B[m                     // Pop the call frame and get the return value if there is one
                     let frame = self.call_frames.pop().unwrap();
[31m-                    
(B[m[32m+
(B[m                     // Push the return value onto the stack if there is one
                     if let Some(return_value) = frame.return_value {
                         self.stack.push(return_value);
Diff in /home/matt/dev/nano-cvm/src/vm.rs:529:
                     }
                 }
[31m-                
(B[m[32m+
(B[m                 Op::Return => {
                     // If we're in a function, set the return value
                     if !self.call_frames.is_empty() {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:539:
                             // If the stack is empty, default to 0.0
                             0.0
                         };
[31m-                        
(B[m[32m+
(B[m                         // Store the return value in the current call frame
                         let frame = self.call_frames.last_mut().unwrap();
                         frame.return_value = Some(return_value);
Diff in /home/matt/dev/nano-cvm/src/vm.rs:546:
[31m-                        
(B[m[32m+
(B[m                         // Exit the current function execution
                         break;
                     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:550:
                 }
[31m-                
(B[m[32m+
(B[m                 Op::Nop => {}
[31m-                
(B[m[31m-                Op::Match { value, cases, default } => {
(B[m[32m+
(B[m[32m+                Op::Match {
(B[m[32m+                    value,
(B[m[32m+                    cases,
(B[m[32m+                    default,
(B[m[32m+                } => {
(B[m                     // Execute value operations to get match value
                     if !value.is_empty() {
                         self.execute_inner(value)?;
Diff in /home/matt/dev/nano-cvm/src/vm.rs:558:
                     }
[31m-                    
(B[m[32m+
(B[m                     // Get the value to match
                     let match_value = self.pop_one("Match")?;
[31m-                    
(B[m[32m+
(B[m                     // Find matching case
                     let mut found_match = false;
                     for (case_value, case_ops) in cases {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:569:
                             break;
                         }
                     }
[31m-                    
(B[m[32m+
(B[m                     // If no match found and there's a default block, execute it
                     if !found_match {
                         if let Some(default_block) = default {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:580:
                         }
                     }
                 }
[31m-                
(B[m[32m+
(B[m                 Op::AssertTop(expected) => {
                     let value = self.pop_one("AssertTop")?;
                     if (value - *expected).abs() >= f64::EPSILON {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:590:
                         });
                     }
                 }
[31m-                
(B[m[32m+
(B[m                 Op::AssertMemory { key, expected } => {
[31m-                    let value = self.memory.get(key)
(B[m[32m+                    let value = self
(B[m[32m+                        .memory
(B[m[32m+                        .get(key)
(B[m                         .ok_or_else(|| VMError::VariableNotFound(key.clone()))?;
                     if (value - expected).abs() >= f64::EPSILON {
                         return Err(VMError::AssertionFailed {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:602:
                     }
                 }
             }
[31m-            
(B[m[32m+
(B[m             pc += 1;
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 
Diff in /home/matt/dev/nano-cvm/src/vm.rs:661:
 
         assert_eq!(
             vm.execute(&ops),
[31m-            Err(VMError::StackUnderflow { 
(B[m[31m-                op: "Add".to_string(), 
(B[m[31m-                needed: 2, 
(B[m[31m-                found: 1 
(B[m[32m+            Err(VMError::StackUnderflow {
(B[m[32m+                op: "Add".to_string(),
(B[m[32m+                needed: 2,
(B[m[32m+                found: 1
(B[m             })
         );
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:688:
         let mut vm = VM::new();
         let ops = vec![Op::Load("nonexistent".to_string())];
 
[31m-        assert_eq!(vm.execute(&ops), Err(VMError::VariableNotFound("nonexistent".to_string())));
(B[m[32m+        assert_eq!(
(B[m[32m+            vm.execute(&ops),
(B[m[32m+            Err(VMError::VariableNotFound("nonexistent".to_string()))
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:698:
 
         assert_eq!(
             vm.execute(&ops),
[31m-            Err(VMError::StackUnderflow { 
(B[m[31m-                op: "Store".to_string(), 
(B[m[31m-                needed: 1, 
(B[m[31m-                found: 0 
(B[m[32m+            Err(VMError::StackUnderflow {
(B[m[32m+                op: "Store".to_string(),
(B[m[32m+                needed: 1,
(B[m[32m+                found: 0
(B[m             })
         );
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:729:
     fn test_if_zero_true() {
         let mut vm = VM::new();
         let ops = vec![
[31m-            Op::Push(0.0),  // Condition value is 0.0 (true in this VM)
(B[m[32m+            Op::Push(0.0), // Condition value is 0.0 (true in this VM)
(B[m             Op::If {
                 condition: vec![],
[31m-                then: vec![Op::Push(42.0)],  // Should execute when condition is 0.0
(B[m[32m+                then: vec![Op::Push(42.0)], // Should execute when condition is 0.0
(B[m                 else_: None,
             },
         ];
Diff in /home/matt/dev/nano-cvm/src/vm.rs:739:
 
         assert!(vm.execute(&ops).is_ok());
[31m-        assert_eq!(vm.top(), Some(42.0));  // Then block executed because condition was 0.0 (true)
(B[m[32m+        assert_eq!(vm.top(), Some(42.0)); // Then block executed because condition was 0.0 (true)
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:745:
     fn test_if_zero_false() {
         let mut vm = VM::new();
         let ops = vec![
[31m-            Op::Push(1.0),  // Condition value is non-zero (false in this VM)
(B[m[32m+            Op::Push(1.0), // Condition value is non-zero (false in this VM)
(B[m             Op::If {
                 condition: vec![],
[31m-                then: vec![Op::Push(42.0)],  // Should not execute
(B[m[32m+                then: vec![Op::Push(42.0)], // Should not execute
(B[m                 else_: None,
             },
         ];
Diff in /home/matt/dev/nano-cvm/src/vm.rs:755:
 
         assert!(vm.execute(&ops).is_ok());
[31m-        assert_eq!(vm.top(), Some(1.0));  // Then block not executed, original value remains
(B[m[32m+        assert_eq!(vm.top(), Some(1.0)); // Then block not executed, original value remains
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:768:
 
         assert_eq!(
             vm.execute(&ops),
[31m-            Err(VMError::StackUnderflow { 
(B[m[31m-                op: "If".to_string(), 
(B[m[31m-                needed: 1, 
(B[m[31m-                found: 0 
(B[m[32m+            Err(VMError::StackUnderflow {
(B[m[32m+                op: "If".to_string(),
(B[m[32m+                needed: 1,
(B[m[32m+                found: 0
(B[m             })
         );
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:780:
     fn test_nested_if_zero() {
         let mut vm = VM::new();
         let ops = vec![
[31m-            Op::Push(0.0),  // Initial stack value (true)
(B[m[32m+            Op::Push(0.0), // Initial stack value (true)
(B[m             Op::If {
                 condition: vec![
[31m-                    Op::Push(1.0),  // Push false for outer condition
(B[m[32m+                    Op::Push(1.0), // Push false for outer condition
(B[m                     Op::If {
[31m-                        condition: vec![Op::Push(0.0)],  // Push true for inner condition
(B[m[31m-                        then: vec![Op::Push(42.0)],      // Should run (condition is true/0.0)
(B[m[32m+                        condition: vec![Op::Push(0.0)], // Push true for inner condition
(B[m[32m+                        then: vec![Op::Push(42.0)],     // Should run (condition is true/0.0)
(B[m                         else_: None,
                     },
                 ],
Diff in /home/matt/dev/nano-cvm/src/vm.rs:793:
[31m-                then: vec![Op::Push(24.0)],  // This should run if the condition evaluates to 0.0
(B[m[32m+                then: vec![Op::Push(24.0)], // This should run if the condition evaluates to 0.0
(B[m                 else_: None,
             },
         ];
Diff in /home/matt/dev/nano-cvm/src/vm.rs:797:
 
         assert!(vm.execute(&ops).is_ok());
[31m-        
(B[m[31m-        // The outer condition operation pushes 1.0 and then contains a nested if 
(B[m[31m-        // that leaves 42.0 on the stack. So the condition is 42.0, not 0.0, 
(B[m[32m+
(B[m[32m+        // The outer condition operation pushes 1.0 and then contains a nested if
(B[m[32m+        // that leaves 42.0 on the stack. So the condition is 42.0, not 0.0,
(B[m         // meaning the then block should not run, leaving 42.0 as the final result.
         assert_eq!(vm.top(), Some(42.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:937:
     #[test]
     fn test_negate() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::Negate,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(42.0), Op::Negate];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(-42.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:949:
     #[test]
     fn test_negate_zero() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(0.0),
(B[m[31m-            Op::Negate,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(0.0), Op::Negate];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(0.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:962:
     fn test_negate_empty_stack() {
         let mut vm = VM::new();
         let ops = vec![Op::Negate];
[31m-        
(B[m[31m-        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
(B[m[31m-            op: "Negate".to_string(), 
(B[m[31m-            needed: 1, 
(B[m[31m-            found: 0 
(B[m[31m-        }));
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            vm.execute(&ops),
(B[m[32m+            Err(VMError::StackUnderflow {
(B[m[32m+                op: "Negate".to_string(),
(B[m[32m+                needed: 1,
(B[m[32m+                found: 0
(B[m[32m+            })
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:974:
     fn test_negate_with_arithmetic() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(5.0),
(B[m[31m-            Op::Push(3.0),
(B[m[31m-            Op::Add,
(B[m[31m-            Op::Negate,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(5.0), Op::Push(3.0), Op::Add, Op::Negate];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(-8.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:987:
     #[test]
     fn test_assert_top_success() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::AssertTop(42.0),
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(42.0), Op::AssertTop(42.0)];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
     }
 
Diff in /home/matt/dev/nano-cvm/src/vm.rs:998:
     #[test]
     fn test_assert_top_failure() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::AssertTop(24.0),
(B[m[31m-        ];
(B[m[31m-        
(B[m[31m-        assert_eq!(vm.execute(&ops), Err(VMError::AssertionFailed { 
(B[m[31m-            expected: 24.0, 
(B[m[31m-            found: 42.0 
(B[m[31m-        }));
(B[m[32m+        let ops = vec![Op::Push(42.0), Op::AssertTop(24.0)];
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            vm.execute(&ops),
(B[m[32m+            Err(VMError::AssertionFailed {
(B[m[32m+                expected: 24.0,
(B[m[32m+                found: 42.0
(B[m[32m+            })
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1013:
     fn test_assert_top_empty_stack() {
         let mut vm = VM::new();
         let ops = vec![Op::AssertTop(42.0)];
[31m-        
(B[m[31m-        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
(B[m[31m-            op: "AssertTop".to_string(), 
(B[m[31m-            needed: 1, 
(B[m[31m-            found: 0 
(B[m[31m-        }));
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            vm.execute(&ops),
(B[m[32m+            Err(VMError::StackUnderflow {
(B[m[32m+                op: "AssertTop".to_string(),
(B[m[32m+                needed: 1,
(B[m[32m+                found: 0
(B[m[32m+            })
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1025:
     fn test_assert_top_with_arithmetic() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(5.0),
(B[m[31m-            Op::Push(3.0),
(B[m[31m-            Op::Add,
(B[m[31m-            Op::AssertTop(8.0),
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(5.0), Op::Push(3.0), Op::Add, Op::AssertTop(8.0)];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
     }
 
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1037:
     #[test]
     fn test_dump_stack() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(1.0),
(B[m[31m-            Op::Push(2.0),
(B[m[31m-            Op::Push(3.0),
(B[m[31m-            Op::DumpStack,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(1.0), Op::Push(2.0), Op::Push(3.0), Op::DumpStack];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.stack, vec![1.0, 2.0, 3.0]);
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1058:
             Op::Store("y".to_string()),
             Op::DumpMemory,
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.get_memory("x"), Some(42.0));
         assert_eq!(vm.get_memory("y"), Some(24.0));
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1068:
     fn test_dump_empty_stack() {
         let mut vm = VM::new();
         let ops = vec![Op::DumpStack];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert!(vm.stack.is_empty());
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1077:
     fn test_dump_empty_memory() {
         let mut vm = VM::new();
         let ops = vec![Op::DumpMemory];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert!(vm.memory.is_empty());
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1085:
     #[test]
     fn test_logic_not_true() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::Not,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(42.0), Op::Not];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(0.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1097:
     #[test]
     fn test_logic_not_false() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(0.0),
(B[m[31m-            Op::Not,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(0.0), Op::Not];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(1.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1110:
     fn test_logic_not_empty_stack() {
         let mut vm = VM::new();
         let ops = vec![Op::Not];
[31m-        
(B[m[31m-        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
(B[m[31m-            op: "Not".to_string(), 
(B[m[31m-            needed: 1, 
(B[m[31m-            found: 0 
(B[m[31m-        }));
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            vm.execute(&ops),
(B[m[32m+            Err(VMError::StackUnderflow {
(B[m[32m+                op: "Not".to_string(),
(B[m[32m+                needed: 1,
(B[m[32m+                found: 0
(B[m[32m+            })
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1122:
     fn test_logic_and_true_true() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::Push(24.0),
(B[m[31m-            Op::And,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(42.0), Op::Push(24.0), Op::And];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(1.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1134:
     #[test]
     fn test_logic_and_true_false() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::Push(0.0),
(B[m[31m-            Op::And,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(42.0), Op::Push(0.0), Op::And];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(0.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1147:
     #[test]
     fn test_logic_and_false_true() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(0.0),
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::And,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(0.0), Op::Push(42.0), Op::And];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(0.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1160:
     #[test]
     fn test_logic_and_false_false() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(0.0),
(B[m[31m-            Op::Push(0.0),
(B[m[31m-            Op::And,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(0.0), Op::Push(0.0), Op::And];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(0.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1174:
     fn test_logic_and_stack_underflow() {
         let mut vm = VM::new();
         let ops = vec![Op::Push(42.0), Op::And];
[31m-        
(B[m[31m-        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
(B[m[31m-            op: "And".to_string(), 
(B[m[31m-            needed: 2, 
(B[m[31m-            found: 1 
(B[m[31m-        }));
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            vm.execute(&ops),
(B[m[32m+            Err(VMError::StackUnderflow {
(B[m[32m+                op: "And".to_string(),
(B[m[32m+                needed: 2,
(B[m[32m+                found: 1
(B[m[32m+            })
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1186:
     fn test_logic_or_true_true() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::Push(24.0),
(B[m[31m-            Op::Or,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(42.0), Op::Push(24.0), Op::Or];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(1.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1198:
     #[test]
     fn test_logic_or_true_false() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::Push(0.0),
(B[m[31m-            Op::Or,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(42.0), Op::Push(0.0), Op::Or];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(1.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1211:
     #[test]
     fn test_logic_or_false_true() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(0.0),
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::Or,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(0.0), Op::Push(42.0), Op::Or];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(1.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1224:
     #[test]
     fn test_logic_or_false_false() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(0.0),
(B[m[31m-            Op::Push(0.0),
(B[m[31m-            Op::Or,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(0.0), Op::Push(0.0), Op::Or];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(0.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1238:
     fn test_logic_or_stack_underflow() {
         let mut vm = VM::new();
         let ops = vec![Op::Push(42.0), Op::Or];
[31m-        
(B[m[31m-        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
(B[m[31m-            op: "Or".to_string(), 
(B[m[31m-            needed: 2, 
(B[m[31m-            found: 1 
(B[m[31m-        }));
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            vm.execute(&ops),
(B[m[32m+            Err(VMError::StackUnderflow {
(B[m[32m+                op: "Or".to_string(),
(B[m[32m+                needed: 2,
(B[m[32m+                found: 1
(B[m[32m+            })
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1253:
             Op::Push(5.0),
             Op::Store("counter".to_string()),
             Op::While {
[31m-                condition: vec![
(B[m[31m-                    Op::Load("counter".to_string()),
(B[m[31m-                    Op::Push(0.0),
(B[m[31m-                    Op::Gt,
(B[m[31m-                ],
(B[m[32m+                condition: vec![Op::Load("counter".to_string()), Op::Push(0.0), Op::Gt],
(B[m                 body: vec![
                     Op::Load("counter".to_string()),
                     Op::Push(1.0),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1267:
             },
             Op::Load("counter".to_string()),
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(0.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1275:
     #[test]
     fn test_while_empty_condition() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::While {
(B[m[31m-                condition: vec![],
(B[m[31m-                body: vec![Op::Push(1.0)],
(B[m[31m-            }
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::While {
(B[m[32m+            condition: vec![],
(B[m[32m+            body: vec![Op::Push(1.0)],
(B[m[32m+        }];
(B[m[32m+
(B[m         assert_eq!(
             vm.execute(&ops),
[31m-            Err(VMError::InvalidCondition("While condition block cannot be empty".to_string()))
(B[m[32m+            Err(VMError::InvalidCondition(
(B[m[32m+                "While condition block cannot be empty".to_string()
(B[m[32m+            ))
(B[m         );
     }
 
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1299:
                 body: vec![Op::Push(42.0)],
             },
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.get_memory("counter"), Some(0.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1307:
     #[test]
     fn test_stack_dup() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::Dup,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(42.0), Op::Dup];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.stack, vec![42.0, 42.0]);
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1320:
     fn test_stack_dup_empty() {
         let mut vm = VM::new();
         let ops = vec![Op::Dup];
[31m-        
(B[m[31m-        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
(B[m[31m-            op: "Dup".to_string(), 
(B[m[31m-            needed: 1, 
(B[m[31m-            found: 0 
(B[m[31m-        }));
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            vm.execute(&ops),
(B[m[32m+            Err(VMError::StackUnderflow {
(B[m[32m+                op: "Dup".to_string(),
(B[m[32m+                needed: 1,
(B[m[32m+                found: 0
(B[m[32m+            })
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1332:
     fn test_stack_swap() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::Push(24.0),
(B[m[31m-            Op::Swap,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(42.0), Op::Push(24.0), Op::Swap];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.stack, vec![24.0, 42.0]);
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1345:
     fn test_stack_swap_underflow() {
         let mut vm = VM::new();
         let ops = vec![Op::Push(42.0), Op::Swap];
[31m-        
(B[m[31m-        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
(B[m[31m-            op: "Swap".to_string(), 
(B[m[31m-            needed: 2, 
(B[m[31m-            found: 1 
(B[m[31m-        }));
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            vm.execute(&ops),
(B[m[32m+            Err(VMError::StackUnderflow {
(B[m[32m+                op: "Swap".to_string(),
(B[m[32m+                needed: 2,
(B[m[32m+                found: 1
(B[m[32m+            })
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1357:
     fn test_stack_over() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::Push(24.0),
(B[m[31m-            Op::Over,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(42.0), Op::Push(24.0), Op::Over];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.stack, vec![42.0, 24.0, 42.0]);
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1370:
     fn test_stack_over_underflow() {
         let mut vm = VM::new();
         let ops = vec![Op::Push(42.0), Op::Over];
[31m-        
(B[m[31m-        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
(B[m[31m-            op: "Over".to_string(), 
(B[m[31m-            needed: 2, 
(B[m[31m-            found: 1 
(B[m[31m-        }));
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            vm.execute(&ops),
(B[m[32m+            Err(VMError::StackUnderflow {
(B[m[32m+                op: "Over".to_string(),
(B[m[32m+                needed: 2,
(B[m[32m+                found: 1
(B[m[32m+            })
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1385:
             Op::Push(1.0),
             Op::Push(2.0),
             Op::Push(3.0),
[31m-            Op::Dup,   // Stack: [1, 2, 3, 3]
(B[m[31m-            Op::Swap,  // Stack: [1, 2, 3, 3] -> [1, 2, 3, 3]
(B[m[31m-            Op::Over,  // Stack: [1, 2, 3, 3, 3]
(B[m[32m+            Op::Dup,  // Stack: [1, 2, 3, 3]
(B[m[32m+            Op::Swap, // Stack: [1, 2, 3, 3] -> [1, 2, 3, 3]
(B[m[32m+            Op::Over, // Stack: [1, 2, 3, 3, 3]
(B[m         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.stack, vec![1.0, 2.0, 3.0, 3.0, 3.0]);
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1401:
             Op::Def {
                 name: "double".to_string(),
                 params: vec![],
[31m-                body: vec![
(B[m[31m-                    Op::Push(2.0),
(B[m[31m-                    Op::Mul,
(B[m[31m-                ],
(B[m[32m+                body: vec![Op::Push(2.0), Op::Mul],
(B[m             },
             Op::Push(21.0),
             Op::Call("double".to_string()),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1411:
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(42.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1418:
     fn test_function_not_found() {
         let mut vm = VM::new();
         let ops = vec![Op::Call("nonexistent".to_string())];
[31m-        
(B[m[31m-        assert_eq!(vm.execute(&ops), Err(VMError::FunctionNotFound("nonexistent".to_string())));
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            vm.execute(&ops),
(B[m[32m+            Err(VMError::FunctionNotFound("nonexistent".to_string()))
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1429:
             Op::Def {
                 name: "add_one".to_string(),
                 params: vec![],
[31m-                body: vec![
(B[m[31m-                    Op::Push(1.0),
(B[m[31m-                    Op::Add,
(B[m[31m-                    Op::Return,
(B[m[31m-                ],
(B[m[32m+                body: vec![Op::Push(1.0), Op::Add, Op::Return],
(B[m             },
             Op::Push(41.0),
             Op::Call("add_one".to_string()),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1440:
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(42.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1459:
             Op::Push(42.0),
             Op::Call("store_and_load".to_string()),
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(42.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1472:
                 name: "countdown".to_string(),
                 params: vec![],
                 body: vec![
[31m-                    Op::Dup,  // Duplicate the value for comparison
(B[m[32m+                    Op::Dup, // Duplicate the value for comparison
(B[m                     Op::Push(0.0),
[31m-                    Op::Eq,   // Will push 1.0 if n==0, 0.0 otherwise
(B[m[32m+                    Op::Eq, // Will push 1.0 if n==0, 0.0 otherwise
(B[m                     Op::If {
                         condition: vec![],
                         then: vec![
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1481:
                             // Already 0, just return
[31m-                            Op::Push(0.0),  // Explicitly push 0 for the result
(B[m[32m+                            Op::Push(0.0), // Explicitly push 0 for the result
(B[m                         ],
                         else_: Some(vec![
                             // n > 0, so decrement and recurse
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1486:
                             Op::Push(1.0),
[31m-                            Op::Sub,      // Decrement n
(B[m[31m-                            Op::Call("countdown".to_string()),  // Recursive call
(B[m[32m+                            Op::Sub,                           // Decrement n
(B[m[32m+                            Op::Call("countdown".to_string()), // Recursive call
(B[m                         ]),
                     },
                 ],
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1492:
             },
[31m-            Op::Push(3.0),  // Use a smaller number to avoid stack overflow
(B[m[32m+            Op::Push(3.0), // Use a smaller number to avoid stack overflow
(B[m             Op::Call("countdown".to_string()),
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(0.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1505:
             Op::Def {
                 name: "push_and_pop".to_string(),
                 params: vec![],
[31m-                body: vec![
(B[m[31m-                    Op::Push(42.0),
(B[m[31m-                    Op::Pop,
(B[m[31m-                    Op::Return,
(B[m[31m-                ],
(B[m[32m+                body: vec![Op::Push(42.0), Op::Pop, Op::Return],
(B[m             },
             Op::Push(24.0),
             Op::Call("push_and_pop".to_string()),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1516:
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(24.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1530:
                 params: vec![],
                 body: vec![
                     Op::Push(24.0),
[31m-                    Op::Store("x".to_string()),  // This should update the function's x, not global x
(B[m[32m+                    Op::Store("x".to_string()), // This should update the function's x, not global x
(B[m                     Op::Return,
                 ],
             },
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1537:
             Op::Call("store_value".to_string()),
             // No return value, so we need to load x to verify it's unchanged
[31m-            Op::Load("x".to_string()),  // Should be 42.0, not 24.0
(B[m[32m+            Op::Load("x".to_string()), // Should be 42.0, not 24.0
(B[m         ];
 
         assert!(vm.execute(&ops).is_ok());
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1543:
[31m-        assert_eq!(vm.top(), Some(42.0));  // Global x should be 42.0
(B[m[32m+        assert_eq!(vm.top(), Some(42.0)); // Global x should be 42.0
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1554:
                     Op::Load("x".to_string()),
                     Op::Push(5.0),
                     Op::Add,
[31m-                    Op::Store("x".to_string()),  // Should modify the local x, not global x
(B[m[31m-                    Op::Load("x".to_string()),   // Should get the modified local x
(B[m[32m+                    Op::Store("x".to_string()), // Should modify the local x, not global x
(B[m[32m+                    Op::Load("x".to_string()),  // Should get the modified local x
(B[m                     Op::Return,
                 ],
             },
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1562:
             Op::Push(10.0),
[31m-            Op::Store("x".to_string()),  // Global x = 10
(B[m[31m-            Op::Push(20.0),              // Parameter value
(B[m[31m-            Op::Call("add_to_param".to_string()),  // Should return 25 (20+5)
(B[m[31m-            Op::Load("x".to_string()),   // Should still be 10 (global x unchanged)
(B[m[32m+            Op::Store("x".to_string()),           // Global x = 10
(B[m[32m+            Op::Push(20.0),                       // Parameter value
(B[m[32m+            Op::Call("add_to_param".to_string()), // Should return 25 (20+5)
(B[m[32m+            Op::Load("x".to_string()),            // Should still be 10 (global x unchanged)
(B[m         ];
[31m-         
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.stack.len(), 2);
[31m-        assert_eq!(vm.stack[0], 25.0);  // Return value from function (parameter + 5)
(B[m[31m-        assert_eq!(vm.stack[1], 10.0);  // Global x value unchanged
(B[m[32m+        assert_eq!(vm.stack[0], 25.0); // Return value from function (parameter + 5)
(B[m[32m+        assert_eq!(vm.stack[1], 10.0); // Global x value unchanged
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1579:
             Op::Def {
                 name: "inner".to_string(),
                 params: vec![],
[31m-                body: vec![
(B[m[31m-                    Op::Push(2.0),
(B[m[31m-                    Op::Mul,
(B[m[31m-                    Op::Return,
(B[m[31m-                ],
(B[m[32m+                body: vec![Op::Push(2.0), Op::Mul, Op::Return],
(B[m             },
             Op::Def {
                 name: "outer".to_string(),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1598:
             Op::Push(7.0),
             Op::Call("outer".to_string()),
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(42.0)); // 7 * 2 * 3
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1621:
             Op::Push(22.0),
             Op::Call("add".to_string()),
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(42.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1643:
             Op::Push(42.0),
             Op::Call("add".to_string()),
         ];
[31m-         
(B[m[31m-        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
(B[m[31m-            op: "Call to function 'add'".to_string(), 
(B[m[31m-            needed: 2, 
(B[m[31m-            found: 1 
(B[m[31m-        }));
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            vm.execute(&ops),
(B[m[32m+            Err(VMError::StackUnderflow {
(B[m[32m+                op: "Call to function 'add'".to_string(),
(B[m[32m+                needed: 2,
(B[m[32m+                found: 1
(B[m[32m+            })
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1659:
                 name: "countdown".to_string(),
                 params: vec!["n".to_string()],
                 body: vec![
[31m-                    Op::Load("n".to_string()),  // Load the parameter
(B[m[32m+                    Op::Load("n".to_string()), // Load the parameter
(B[m                     Op::Push(0.0),
[31m-                    Op::Eq,   // Will push 1.0 if n==0, 0.0 otherwise
(B[m[32m+                    Op::Eq, // Will push 1.0 if n==0, 0.0 otherwise
(B[m                     Op::If {
                         condition: vec![],
                         then: vec![
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1668:
[31m-                            Op::Push(0.0),  // Return 0 when n==0
(B[m[32m+                            Op::Push(0.0), // Return 0 when n==0
(B[m                         ],
                         else_: Some(vec![
                             // n > 0, so decrement and recurse
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1672:
                             Op::Load("n".to_string()),
                             Op::Push(1.0),
[31m-                            Op::Sub,                       // Compute n-1
(B[m[31m-                            Op::Call("countdown".to_string()),  // Call countdown(n-1)
(B[m[32m+                            Op::Sub,                           // Compute n-1
(B[m[32m+                            Op::Call("countdown".to_string()), // Call countdown(n-1)
(B[m                         ]),
                     },
                     // Return (implicit)
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1681:
             Op::Push(5.0),
             Op::Call("countdown".to_string()),
         ];
[31m-         
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(0.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1714:
             Op::Push(7.0),
             Op::Call("outer".to_string()),
         ];
[31m-         
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(42.0)); // 7 * 2 * 3
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1744:
             },
             Op::Load("counter".to_string()),
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(5.0)); // Loop should break at counter = 5
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1751:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_continue_in_loop() {
         let mut vm = VM::new();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1764:
                     Op::Push(1.0),
                     Op::Add,
                     Op::Store("counter".to_string()),
[31m-                    
(B[m                     // Skip odd numbers
                     Op::Load("counter".to_string()),
                     Op::Push(2.0),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1777:
                         then: vec![Op::Continue],
                         else_: None,
                     },
[31m-                    
(B[m                     // Add even numbers to sum
                     Op::Load("sum".to_string()),
                     Op::Load("counter".to_string()),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1787:
             },
             Op::Load("sum".to_string()),
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(30.0)); // Sum of even numbers from 2 to 10 = 2+4+6+8+10 = 30
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1794:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_break_in_while() {
         let mut vm = VM::new();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1798:
[31m-        
(B[m[32m+
(B[m         // Create a simpler test case that's more likely to work
         let ops = vec![
             Op::Push(0.0),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1802:
             Op::Store("counter".to_string()),
             Op::While {
                 condition: vec![
[31m-                    Op::Push(0.0),  // True condition (0.0)
(B[m[32m+                    Op::Push(0.0), // True condition (0.0)
(B[m                 ],
                 body: vec![
                     // Increment counter
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1810:
                     Op::Push(1.0),
                     Op::Add,
                     Op::Store("counter".to_string()),
[31m-                    
(B[m                     // If counter == 5, break
                     Op::Load("counter".to_string()),
                     Op::Push(5.0),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1825:
             // Load the counter to verify
             Op::Load("counter".to_string()),
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(5.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1832:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_continue_in_while() {
         let mut vm = VM::new();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1839:
             Op::Push(0.0),
             Op::Store("counter".to_string()),
             Op::While {
[31m-                condition: vec![
(B[m[31m-                    Op::Load("counter".to_string()),
(B[m[31m-                    Op::Push(10.0),
(B[m[31m-                    Op::Lt,
(B[m[31m-                ],
(B[m[32m+                condition: vec![Op::Load("counter".to_string()), Op::Push(10.0), Op::Lt],
(B[m                 body: vec![
                     Op::Load("counter".to_string()),
                     Op::Push(1.0),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1850:
                     Op::Add,
                     Op::Store("counter".to_string()),
[31m-                    
(B[m                     // Skip odd numbers
                     Op::Load("counter".to_string()),
                     Op::Push(2.0),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1862:
                         then: vec![Op::Continue],
                         else_: None,
                     },
[31m-                    
(B[m                     // Add even numbers to sum
                     Op::Load("sum".to_string()),
                     Op::Load("counter".to_string()),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1872:
             },
             Op::Load("sum".to_string()),
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(30.0)); // Sum of even numbers from 2 to 10 = 2+4+6+8+10 = 30
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1879:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_match_statement() {
         let mut vm = VM::new();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1892:
                 default: Some(vec![Op::Push(0.0)]),
             },
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(20.0)); // Should match case 2
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1899:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_match_with_default() {
         let mut vm = VM::new();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1912:
                 default: Some(vec![Op::Push(999.0)]),
             },
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(999.0)); // Should execute default
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1919:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_match_no_default() {
         let mut vm = VM::new();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1932:
                 default: None,
             },
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(5.0)); // Should keep original value
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1939:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_match_with_computed_value() {
         let mut vm = VM::new();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1943:
[31m-        let ops = vec![
(B[m[31m-            Op::Match {
(B[m[31m-                value: vec![
(B[m[31m-                    Op::Push(1.0),
(B[m[31m-                    Op::Push(2.0),
(B[m[31m-                    Op::Add,
(B[m[31m-                ],
(B[m[31m-                cases: vec![
(B[m[31m-                    (1.0, vec![Op::Push(10.0)]),
(B[m[31m-                    (3.0, vec![Op::Push(30.0)]),
(B[m[31m-                    (4.0, vec![Op::Push(40.0)]),
(B[m[31m-                ],
(B[m[31m-                default: Some(vec![Op::Push(999.0)]),
(B[m[31m-            },
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Match {
(B[m[32m+            value: vec![Op::Push(1.0), Op::Push(2.0), Op::Add],
(B[m[32m+            cases: vec![
(B[m[32m+                (1.0, vec![Op::Push(10.0)]),
(B[m[32m+                (3.0, vec![Op::Push(30.0)]),
(B[m[32m+                (4.0, vec![Op::Push(40.0)]),
(B[m[32m+            ],
(B[m[32m+            default: Some(vec![Op::Push(999.0)]),
(B[m[32m+        }];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(30.0)); // 1+2=3, should match case 3
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1962:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_emit_event() {
         let mut vm = VM::new();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1970:
             },
             Op::Push(42.0), // Just to verify execution continues
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(42.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1977:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_assert_equal_stack_success() {
         let mut vm = VM::new();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1984:
             Op::Push(42.0),
             Op::AssertEqualStack { depth: 3 },
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.stack, vec![42.0, 42.0, 42.0]);
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1991:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_assert_equal_stack_failure() {
         let mut vm = VM::new();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1998:
             Op::Push(42.0),
             Op::AssertEqualStack { depth: 3 },
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_err());
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_assert_equal_stack_underflow() {
         let mut vm = VM::new();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:2008:
[31m-        let ops = vec![
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::AssertEqualStack { depth: 3 },
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(42.0), Op::AssertEqualStack { depth: 3 }];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_err());
     }
 }
[1;38;5;9merror[internal][0m: [1mleft behind trailing whitespace[0m
   [1;38;5;12m-->[0m /home/matt/dev/nano-cvm/src/vm.rs:378:378:36
[1;38;5;12m    |[0m
[1;38;5;12m378 |[0m                         self.stack, 
[1;38;5;12m    |[0m[1;38;5;9m                                    ^[0m
[1;38;5;12m    |[0m

[1;38;5;9merror[internal][0m: [1mleft behind trailing whitespace[0m
   [1;38;5;12m-->[0m /home/matt/dev/nano-cvm/src/vm.rs:379:379:37
[1;38;5;12m    |[0m
[1;38;5;12m379 |[0m                         self.memory, 
[1;38;5;12m    |[0m[1;38;5;9m                                     ^[0m
[1;38;5;12m    |[0m

[1;38;5;11mwarning[0m: [1mrustfmt has failed to format. See previous 2 errors.[0m

Diff in /home/matt/dev/nano-cvm/src/compiler/common.rs:34:
 /// Helper to find nested blocks within indented code
 pub fn find_block_end(lines: &[String], start_line: usize, base_indent: usize) -> usize {
     let mut end_line = start_line;
[31m-    
(B[m[32m+
(B[m     while end_line < lines.len() && get_indent(&lines[end_line]) > base_indent {
         end_line += 1;
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/common.rs:41:
[31m-    
(B[m[32m+
(B[m     end_line
 }
 
Diff in /home/matt/dev/nano-cvm/src/compiler/common.rs:46:
 pub fn collect_block_lines(lines: &[String], start_line: usize, base_indent: usize) -> Vec<String> {
     let end_line = find_block_end(lines, start_line, base_indent);
     lines[start_line..end_line].to_vec()
[31m-} 
(B[m[32m+}
(B[m[32m+
(B[mDiff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:1:
[32m+use super::{common, line_parser, CompilerError, SourcePosition};
(B[m use crate::vm::Op;
[31m-use super::{CompilerError, SourcePosition, common, line_parser};
(B[m 
 /// Parse a function definition block
[31m-pub fn parse_function_block(lines: &[String], current_line: &mut usize, pos: SourcePosition) -> Result<Op, CompilerError> {
(B[m[32m+pub fn parse_function_block(
(B[m[32m+    lines: &[String],
(B[m[32m+    current_line: &mut usize,
(B[m[32m+    pos: SourcePosition,
(B[m[32m+) -> Result<Op, CompilerError> {
(B[m     let line = &lines[*current_line];
[31m-    
(B[m[32m+
(B[m     // Expected format: def name(param1, param2):
     if !line.contains('(') || !line.contains(')') {
[31m-        return Err(CompilerError::InvalidFunctionFormat(line.to_string(), pos.line, pos.column));
(B[m[32m+        return Err(CompilerError::InvalidFunctionFormat(
(B[m[32m+            line.to_string(),
(B[m[32m+            pos.line,
(B[m[32m+            pos.column,
(B[m[32m+        ));
(B[m     }
[31m-    
(B[m[32m+
(B[m     // Extract name and parameters
     let name_params = parse_function_signature(line, pos)?;
     let name = name_params.0;
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:16:
     let params = name_params.1;
[31m-    
(B[m[32m+
(B[m     let current_indent = common::get_indent(line);
     *current_line += 1;
[31m-    
(B[m[32m+
(B[m     // Parse function body
     let body = line_parser::parse_block(lines, current_line, current_indent, pos)?;
[31m-    
(B[m[31m-    Ok(Op::Def {
(B[m[31m-        name,
(B[m[31m-        params,
(B[m[31m-        body,
(B[m[31m-    })
(B[m[32m+
(B[m[32m+    Ok(Op::Def { name, params, body })
(B[m }
 
 /// Helper function to parse function signature
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:32:
[31m-pub fn parse_function_signature(line: &str, pos: SourcePosition) -> Result<(String, Vec<String>), CompilerError> {
(B[m[32m+pub fn parse_function_signature(
(B[m[32m+    line: &str,
(B[m[32m+    pos: SourcePosition,
(B[m[32m+) -> Result<(String, Vec<String>), CompilerError> {
(B[m     // Format: def name(x, y):
     let parts: Vec<&str> = line.trim_end_matches(':').splitn(2, '(').collect();
     if parts.len() != 2 {
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:36:
[31m-        return Err(CompilerError::InvalidFunctionDefinition(line.to_string(), pos.line, pos.column));
(B[m[32m+        return Err(CompilerError::InvalidFunctionDefinition(
(B[m[32m+            line.to_string(),
(B[m[32m+            pos.line,
(B[m[32m+            pos.column,
(B[m[32m+        ));
(B[m     }
 
     let name_part = parts[0].trim();
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:40:
     if !name_part.starts_with("def ") {
[31m-        return Err(CompilerError::InvalidFunctionStart(line.to_string(), pos.line, pos.column));
(B[m[32m+        return Err(CompilerError::InvalidFunctionStart(
(B[m[32m+            line.to_string(),
(B[m[32m+            pos.line,
(B[m[32m+            pos.column,
(B[m[32m+        ));
(B[m     }
[31m-    
(B[m[32m+
(B[m     let name = name_part["def ".len()..].trim().to_string();
[31m-    
(B[m[32m+
(B[m     // Extract parameters
     let params_str = parts[1].trim_end_matches(')');
     let params: Vec<String> = params_str
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:57:
 #[cfg(test)]
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_function_block_parsing() {
         let source = vec![
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:67:
             "    add".to_string(),
             "    return".to_string(),
         ];
[31m-        
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let op = parse_function_block(&source, &mut current_line, pos).unwrap();
[31m-        
(B[m[32m+
(B[m         match op {
             Op::Def { name, params, body } => {
                 assert_eq!(name, "add");
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:79:
                 assert_eq!(params, vec!["x".to_string(), "y".to_string()]);
                 assert_eq!(body.len(), 4);
[31m-            },
(B[m[32m+            }
(B[m             _ => panic!("Expected Def operation"),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:85:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_function_without_params() {
         let source = vec![
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:90:
             "    push 42".to_string(),
             "    return".to_string(),
         ];
[31m-        
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let op = parse_function_block(&source, &mut current_line, pos).unwrap();
[31m-        
(B[m[32m+
(B[m         match op {
             Op::Def { name, params, body } => {
                 assert_eq!(name, "constant");
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:102:
                 assert_eq!(params.len(), 0);
                 assert_eq!(body.len(), 2);
[31m-            },
(B[m[32m+            }
(B[m             _ => panic!("Expected Def operation"),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:108:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_invalid_function_signature() {
[31m-        let source = vec![
(B[m[31m-            "def invalid".to_string(),
(B[m[31m-            "    push 1".to_string(),
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let source = vec!["def invalid".to_string(), "    push 1".to_string()];
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let result = parse_function_block(&source, &mut current_line, pos);
         assert!(result.is_err());
[31m-        
(B[m[32m+
(B[m         match result.unwrap_err() {
             CompilerError::InvalidFunctionFormat(_, line, _) => {
                 assert_eq!(line, 1);
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:125:
[31m-            },
(B[m[32m+            }
(B[m             err => panic!("Expected InvalidFunctionFormat error, got {:?}", err),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/function_block.rs:129:
[31m-} 
(B[m[32m+}
(B[m[32m+
(B[mDiff in /home/matt/dev/nano-cvm/src/compiler/if_block.rs:1:
[32m+use super::{common, line_parser, CompilerError, SourcePosition};
(B[m use crate::vm::Op;
[31m-use super::{CompilerError, SourcePosition, common, line_parser};
(B[m 
 /// Parse an if statement block
[31m-pub fn parse_if_block(lines: &[String], current_line: &mut usize, pos: SourcePosition) -> Result<Op, CompilerError> {
(B[m[32m+pub fn parse_if_block(
(B[m[32m+    lines: &[String],
(B[m[32m+    current_line: &mut usize,
(B[m[32m+    pos: SourcePosition,
(B[m[32m+) -> Result<Op, CompilerError> {
(B[m     let mut condition = Vec::new();
     let mut then_block = Vec::new();
     let mut else_block = None;
Diff in /home/matt/dev/nano-cvm/src/compiler/if_block.rs:16:
 
     // Check for else block
     if *current_line < lines.len() && lines[*current_line].trim() == "else:" {
[31m-        let else_pos = SourcePosition::new(pos.line + *current_line, common::get_indent(&lines[*current_line]) + 1);
(B[m[32m+        let else_pos = SourcePosition::new(
(B[m[32m+            pos.line + *current_line,
(B[m[32m+            common::get_indent(&lines[*current_line]) + 1,
(B[m[32m+        );
(B[m         *current_line += 1;
[31m-        
(B[m[32m+
(B[m         let else_ops = line_parser::parse_block(lines, current_line, current_indent, else_pos)?;
         else_block = Some(else_ops);
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/if_block.rs:33:
 #[cfg(test)]
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_if_block_parsing() {
         let source = vec![
Diff in /home/matt/dev/nano-cvm/src/compiler/if_block.rs:44:
             "else:".to_string(),
             "    push 0".to_string(),
         ];
[31m-        
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let op = parse_if_block(&source, &mut current_line, pos).unwrap();
[31m-        
(B[m[32m+
(B[m         match op {
[31m-            Op::If { condition: _, then, else_ } => {
(B[m[32m+            Op::If {
(B[m[32m+                condition: _,
(B[m[32m+                then,
(B[m[32m+                else_,
(B[m[32m+            } => {
(B[m                 assert_eq!(then.len(), 3);
                 assert!(else_.is_some());
                 let else_block = else_.unwrap();
Diff in /home/matt/dev/nano-cvm/src/compiler/if_block.rs:58:
                 assert_eq!(else_block.len(), 1);
[31m-            },
(B[m[32m+            }
(B[m             _ => panic!("Expected If operation"),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/if_block.rs:63:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_nested_if_blocks() {
         let source = vec![
Diff in /home/matt/dev/nano-cvm/src/compiler/if_block.rs:74:
             "else:".to_string(),
             "    push 0".to_string(),
         ];
[31m-        
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let op = parse_if_block(&source, &mut current_line, pos).unwrap();
[31m-        
(B[m[32m+
(B[m         match op {
[31m-            Op::If { condition: _, then, else_ } => {
(B[m[32m+            Op::If {
(B[m[32m+                condition: _,
(B[m[32m+                then,
(B[m[32m+                else_,
(B[m[32m+            } => {
(B[m                 assert_eq!(then.len(), 2); // push 1 and nested if
                 assert!(else_.is_some());
[31m-                
(B[m[32m+
(B[m                 // Check nested if
                 match &then[1] {
[31m-                    Op::If { condition: _, then: nested_then, else_: nested_else } => {
(B[m[32m+                    Op::If {
(B[m[32m+                        condition: _,
(B[m[32m+                        then: nested_then,
(B[m[32m+                        else_: nested_else,
(B[m[32m+                    } => {
(B[m                         assert_eq!(nested_then.len(), 2);
                         assert!(nested_else.is_some());
[31m-                    },
(B[m[32m+                    }
(B[m                     _ => panic!("Expected nested If operation"),
                 }
[31m-            },
(B[m[32m+            }
(B[m             _ => panic!("Expected If operation"),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/if_block.rs:100:
[31m-} 
(B[m[32m+}
(B[m[32m+
(B[mDiff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:1:
[32m+use super::{common, CompilerError, SourcePosition};
(B[m use crate::vm::Op;
[31m-use super::{CompilerError, SourcePosition, common};
(B[m 
 /// Parse a single line of DSL code
 pub fn parse_line(line: &str, pos: SourcePosition) -> Result<Op, CompilerError> {
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:16:
 
     match command {
         "push" => {
[31m-            let num_str = parts.next().ok_or(CompilerError::MissingPushValue(pos.line, pos.column))?;
(B[m[31m-            let num = num_str.parse::<f64>()
(B[m[31m-                .map_err(|_| CompilerError::InvalidPushValue(
(B[m[31m-                    num_str.to_string(), 
(B[m[31m-                    pos.line, 
(B[m[31m-                    common::adjusted_position(pos, line, num_str).column
(B[m[31m-                ))?;
(B[m[32m+            let num_str = parts
(B[m[32m+                .next()
(B[m[32m+                .ok_or(CompilerError::MissingPushValue(pos.line, pos.column))?;
(B[m[32m+            let num = num_str.parse::<f64>().map_err(|_| {
(B[m[32m+                CompilerError::InvalidPushValue(
(B[m[32m+                    num_str.to_string(),
(B[m[32m+                    pos.line,
(B[m[32m+                    common::adjusted_position(pos, line, num_str).column,
(B[m[32m+                )
(B[m[32m+            })?;
(B[m             Ok(Op::Push(num))
         }
         "emit" => {
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:40:
             if parts.len() < 5 {
                 return Err(CompilerError::InvalidEmitEventFormat(pos.line, pos.column));
             }
[31m-            
(B[m[32m+
(B[m             let category = parts[1].trim().to_string();
             let message = parts[3].trim().to_string();
[31m-            
(B[m[32m+
(B[m             Ok(Op::EmitEvent { category, message })
         }
         "assertequalstack" => {
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:50:
[31m-            let depth_str = parts.next().ok_or(CompilerError::MissingAssertDepth(pos.line, pos.column))?;
(B[m[31m-            let depth = depth_str.parse::<usize>()
(B[m[31m-                .map_err(|_| CompilerError::InvalidAssertDepth(
(B[m[31m-                    depth_str.to_string(), 
(B[m[31m-                    pos.line, 
(B[m[31m-                    common::adjusted_position(pos, line, depth_str).column
(B[m[31m-                ))?;
(B[m[31m-            
(B[m[32m+            let depth_str = parts
(B[m[32m+                .next()
(B[m[32m+                .ok_or(CompilerError::MissingAssertDepth(pos.line, pos.column))?;
(B[m[32m+            let depth = depth_str.parse::<usize>().map_err(|_| {
(B[m[32m+                CompilerError::InvalidAssertDepth(
(B[m[32m+                    depth_str.to_string(),
(B[m[32m+                    pos.line,
(B[m[32m+                    common::adjusted_position(pos, line, depth_str).column,
(B[m[32m+                )
(B[m[32m+            })?;
(B[m[32m+
(B[m             if depth < 2 {
                 return Err(CompilerError::InsufficientAssertDepth(pos.line, pos.column));
             }
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:61:
[31m-            
(B[m[32m+
(B[m             Ok(Op::AssertEqualStack { depth })
         }
         "break" => Ok(Op::Break),
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:65:
         "continue" => Ok(Op::Continue),
         "load" => {
             let var_name = parts.next().ok_or(CompilerError::MissingVariable(
[31m-                "load".to_string(), 
(B[m[31m-                pos.line, 
(B[m[31m-                pos.column
(B[m[32m+                "load".to_string(),
(B[m[32m+                pos.line,
(B[m[32m+                pos.column,
(B[m             ))?;
             Ok(Op::Load(var_name.to_string()))
[31m-        },
(B[m[32m+        }
(B[m         "store" => {
             let var_name = parts.next().ok_or(CompilerError::MissingVariable(
[31m-                "store".to_string(), 
(B[m[31m-                pos.line, 
(B[m[31m-                pos.column
(B[m[32m+                "store".to_string(),
(B[m[32m+                pos.line,
(B[m[32m+                pos.column,
(B[m             ))?;
             Ok(Op::Store(var_name.to_string()))
[31m-        },
(B[m[32m+        }
(B[m         "add" => Ok(Op::Add),
         "sub" => Ok(Op::Sub),
         "mul" => Ok(Op::Mul),
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:97:
         "pop" => Ok(Op::Pop),
         "return" => Ok(Op::Return),
         "call" => {
[31m-            let fn_name = parts.next().ok_or(CompilerError::MissingFunctionName(pos.line, pos.column))?;
(B[m[32m+            let fn_name = parts
(B[m[32m+                .next()
(B[m[32m+                .ok_or(CompilerError::MissingFunctionName(pos.line, pos.column))?;
(B[m             Ok(Op::Call(fn_name.to_string()))
[31m-        },
(B[m[32m+        }
(B[m         "dumpstack" => Ok(Op::DumpStack),
         "dumpmemory" => Ok(Op::DumpMemory),
         "dumpstate" => Ok(Op::DumpState), // New debug/introspection opcode
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:106:
[31m-        _ => Err(CompilerError::UnknownCommand(command.to_string(), pos.line, pos.column)),
(B[m[32m+        _ => Err(CompilerError::UnknownCommand(
(B[m[32m+            command.to_string(),
(B[m[32m+            pos.line,
(B[m[32m+            pos.column,
(B[m[32m+        )),
(B[m     }
 }
 
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:110:
 /// Parse a series of lines as a block of code
[31m-pub fn parse_block(lines: &[String], start_line: &mut usize, base_indent: usize, pos: SourcePosition) -> Result<Vec<Op>, CompilerError> {
(B[m[32m+pub fn parse_block(
(B[m[32m+    lines: &[String],
(B[m[32m+    start_line: &mut usize,
(B[m[32m+    base_indent: usize,
(B[m[32m+    pos: SourcePosition,
(B[m[32m+) -> Result<Vec<Op>, CompilerError> {
(B[m     let mut block_ops = Vec::new();
 
     while *start_line < lines.len() {
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:115:
         let line = &lines[*start_line];
         let indent = common::get_indent(line);
[31m-        
(B[m[32m+
(B[m         // If we've dedented, we're done with this block
         if indent <= base_indent || line.trim().is_empty() {
             break;
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:121:
         }
[31m-        
(B[m[32m+
(B[m         let current_pos = SourcePosition::new(pos.line + *start_line, indent + 1);
[31m-        
(B[m[32m+
(B[m         // Detect and parse nested blocks
         if line.trim().ends_with(':') {
             let op = if line.trim() == "if:" {
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:135:
             } else if line.trim().starts_with("loop ") {
                 super::loop_block::parse_loop_block(lines, start_line, current_pos)?
             } else {
[31m-                return Err(CompilerError::UnknownBlockType(line.trim().to_string(), current_pos.line, current_pos.column));
(B[m[32m+                return Err(CompilerError::UnknownBlockType(
(B[m[32m+                    line.trim().to_string(),
(B[m[32m+                    current_pos.line,
(B[m[32m+                    current_pos.column,
(B[m[32m+                ));
(B[m             };
[31m-            
(B[m[32m+
(B[m             if !matches!(op, Op::Nop) {
                 block_ops.push(op);
             }
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:144:
[31m-            
(B[m[32m+
(B[m             // Don't increment start_line here since the block parser already did it
         } else {
             // Regular statements
Diff in /home/matt/dev/nano-cvm/src/compiler/line_parser.rs:152:
             *start_line += 1;
         }
     }
[31m-    
(B[m[32m+
(B[m     Ok(block_ops)
[31m-} 
(B[m[32m+}
(B[m[32m+
(B[mDiff in /home/matt/dev/nano-cvm/src/compiler/loop_block.rs:1:
[32m+use super::{common, line_parser, CompilerError, SourcePosition};
(B[m use crate::vm::Op;
[31m-use super::{CompilerError, SourcePosition, common, line_parser};
(B[m 
 /// Parse a loop statement block
[31m-pub fn parse_loop_block(lines: &[String], current_line: &mut usize, pos: SourcePosition) -> Result<Op, CompilerError> {
(B[m[32m+pub fn parse_loop_block(
(B[m[32m+    lines: &[String],
(B[m[32m+    current_line: &mut usize,
(B[m[32m+    pos: SourcePosition,
(B[m[32m+) -> Result<Op, CompilerError> {
(B[m     // Parse the "loop N:" line, extracting N
     let line = &lines[*current_line];
     let parts: Vec<&str> = line.trim().splitn(2, ' ').collect();
Diff in /home/matt/dev/nano-cvm/src/compiler/loop_block.rs:9:
     if parts.len() != 2 || !parts[0].eq_ignore_ascii_case("loop") {
[31m-        return Err(CompilerError::InvalidLoopFormat(line.trim().to_string(), pos.line, pos.column));
(B[m[32m+        return Err(CompilerError::InvalidLoopFormat(
(B[m[32m+            line.trim().to_string(),
(B[m[32m+            pos.line,
(B[m[32m+            pos.column,
(B[m[32m+        ));
(B[m     }
[31m-    
(B[m[32m+
(B[m     let count_str = parts[1].trim_end_matches(':');
[31m-    let count = count_str.parse::<usize>()
(B[m[31m-        .map_err(|_| CompilerError::InvalidLoopCount(
(B[m[31m-            count_str.to_string(), 
(B[m[31m-            pos.line, 
(B[m[31m-            common::adjusted_position(pos, line, count_str).column
(B[m[31m-        ))?;
(B[m[31m-    
(B[m[32m+    let count = count_str.parse::<usize>().map_err(|_| {
(B[m[32m+        CompilerError::InvalidLoopCount(
(B[m[32m+            count_str.to_string(),
(B[m[32m+            pos.line,
(B[m[32m+            common::adjusted_position(pos, line, count_str).column,
(B[m[32m+        )
(B[m[32m+    })?;
(B[m[32m+
(B[m     let current_indent = common::get_indent(line);
[31m-    
(B[m[32m+
(B[m     // Skip the "loop N:" line
     *current_line += 1;
[31m-    
(B[m[32m+
(B[m     // Parse the body
     let body = line_parser::parse_block(lines, current_line, current_indent, pos)?;
[31m-    
(B[m[32m+
(B[m     Ok(Op::Loop { count, body })
 }
 
Diff in /home/matt/dev/nano-cvm/src/compiler/loop_block.rs:32:
 #[cfg(test)]
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_loop_block_parsing() {
         let source = vec![
Diff in /home/matt/dev/nano-cvm/src/compiler/loop_block.rs:41:
             "    push 2".to_string(),
             "    add".to_string(),
         ];
[31m-        
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let op = parse_loop_block(&source, &mut current_line, pos).unwrap();
[31m-        
(B[m[32m+
(B[m         match op {
             Op::Loop { count, body } => {
                 assert_eq!(count, 5);
Diff in /home/matt/dev/nano-cvm/src/compiler/loop_block.rs:53:
                 assert_eq!(body.len(), 3);
[31m-            },
(B[m[32m+            }
(B[m             _ => panic!("Expected Loop operation"),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/loop_block.rs:58:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_nested_loop_blocks() {
         let source = vec![
Diff in /home/matt/dev/nano-cvm/src/compiler/loop_block.rs:65:
             "        push 2".to_string(),
             "        add".to_string(),
         ];
[31m-        
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let op = parse_loop_block(&source, &mut current_line, pos).unwrap();
[31m-        
(B[m[32m+
(B[m         match op {
             Op::Loop { count, body } => {
                 assert_eq!(count, 3);
Diff in /home/matt/dev/nano-cvm/src/compiler/loop_block.rs:77:
                 assert_eq!(body.len(), 2); // push 1 and nested loop
[31m-                
(B[m[32m+
(B[m                 // Check nested loop
                 match &body[1] {
[31m-                    Op::Loop { count: nested_count, body: nested_body } => {
(B[m[32m+                    Op::Loop {
(B[m[32m+                        count: nested_count,
(B[m[32m+                        body: nested_body,
(B[m[32m+                    } => {
(B[m                         assert_eq!(*nested_count, 2);
                         assert_eq!(nested_body.len(), 2);
[31m-                    },
(B[m[32m+                    }
(B[m                     _ => panic!("Expected nested Loop operation"),
                 }
[31m-            },
(B[m[32m+            }
(B[m             _ => panic!("Expected Loop operation"),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/loop_block.rs:91:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_invalid_loop_count() {
[31m-        let source = vec![
(B[m[31m-            "loop abc:".to_string(),
(B[m[31m-            "    push 1".to_string(),
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let source = vec!["loop abc:".to_string(), "    push 1".to_string()];
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let result = parse_loop_block(&source, &mut current_line, pos);
         assert!(result.is_err());
[31m-        
(B[m[32m+
(B[m         match result.unwrap_err() {
             CompilerError::InvalidLoopCount(_, line, _) => {
                 assert_eq!(line, 1);
Diff in /home/matt/dev/nano-cvm/src/compiler/loop_block.rs:108:
[31m-            },
(B[m[32m+            }
(B[m             err => panic!("Expected InvalidLoopCount error, got {:?}", err),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/loop_block.rs:112:
[31m-} 
(B[m[32m+}
(B[m[32m+
(B[mDiff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:1:
[32m+use super::{common, line_parser, CompilerError, SourcePosition};
(B[m use crate::vm::Op;
[31m-use super::{CompilerError, SourcePosition, common, line_parser};
(B[m 
 /// Parse a match statement block
[31m-pub fn parse_match_block(lines: &[String], current_line: &mut usize, pos: SourcePosition) -> Result<Op, CompilerError> {
(B[m[32m+pub fn parse_match_block(
(B[m[32m+    lines: &[String],
(B[m[32m+    current_line: &mut usize,
(B[m[32m+    pos: SourcePosition,
(B[m[32m+) -> Result<Op, CompilerError> {
(B[m     let mut value_ops = Vec::new();
     let mut cases = Vec::new();
     let mut default_ops = None;
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:9:
     let current_indent = common::get_indent(&lines[*current_line]);
[31m-    
(B[m[32m+
(B[m     // Skip the "match:" line
     *current_line += 1;
[31m-    
(B[m[32m+
(B[m     // Parse the body of the match statement
     while *current_line < lines.len() {
         let line = &lines[*current_line];
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:17:
         let indent = common::get_indent(line);
[31m-        
(B[m[32m+
(B[m         if indent <= current_indent {
             break;
         }
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:22:
[31m-        
(B[m[32m+
(B[m         let line_pos = SourcePosition::new(pos.line + *current_line, indent + 1);
[31m-        
(B[m[32m+
(B[m         if line.trim() == "value:" {
             *current_line += 1;
             // Parse the value block
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:28:
             let value_indent = indent;
             let value_pos = SourcePosition::new(line_pos.line + 1, indent + 1);
[31m-            
(B[m[32m+
(B[m             value_ops = line_parser::parse_block(lines, current_line, value_indent, value_pos)?;
         } else if line.trim().starts_with("case ") {
             // Parse case value
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:34:
             let case_line = line.trim();
             let case_value_str = case_line[5..].trim().trim_end_matches(':');
[31m-            let case_value = case_value_str.parse::<f64>()
(B[m[31m-                .map_err(|_| CompilerError::InvalidCaseValue(
(B[m[31m-                    case_value_str.to_string(), 
(B[m[31m-                    line_pos.line, 
(B[m[31m-                    common::adjusted_position(line_pos, line, case_value_str).column
(B[m[31m-                ))?;
(B[m[31m-            
(B[m[32m+            let case_value = case_value_str.parse::<f64>().map_err(|_| {
(B[m[32m+                CompilerError::InvalidCaseValue(
(B[m[32m+                    case_value_str.to_string(),
(B[m[32m+                    line_pos.line,
(B[m[32m+                    common::adjusted_position(line_pos, line, case_value_str).column,
(B[m[32m+                )
(B[m[32m+            })?;
(B[m[32m+
(B[m             let case_indent = indent;
             *current_line += 1;
[31m-            
(B[m[32m+
(B[m             // Parse case block
             let case_pos = SourcePosition::new(line_pos.line + 1, indent + 1);
             let case_ops = line_parser::parse_block(lines, current_line, case_indent, case_pos)?;
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:49:
[31m-            
(B[m[32m+
(B[m             cases.push((case_value, case_ops));
         } else if line.trim() == "default:" {
             *current_line += 1;
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:53:
             let default_indent = indent;
[31m-            
(B[m[32m+
(B[m             // Parse default block
             let default_pos = SourcePosition::new(line_pos.line + 1, indent + 1);
[31m-            let default_block = line_parser::parse_block(lines, current_line, default_indent, default_pos)?;
(B[m[31m-            
(B[m[32m+            let default_block =
(B[m[32m+                line_parser::parse_block(lines, current_line, default_indent, default_pos)?;
(B[m[32m+
(B[m             default_ops = Some(default_block);
         } else {
             // If not in a special block, assume it's part of the value
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:66:
             *current_line += 1;
         }
     }
[31m-    
(B[m[32m+
(B[m     if value_ops.is_empty() {
         return Err(CompilerError::MissingMatchValue(pos.line, pos.column));
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:73:
[31m-    
(B[m[32m+
(B[m     Ok(Op::Match {
         value: value_ops,
         cases,
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:81:
 #[cfg(test)]
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_match_block_parsing() {
         let source = vec![
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:95:
             "    default:".to_string(),
             "        push 0".to_string(),
         ];
[31m-        
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let op = parse_match_block(&source, &mut current_line, pos).unwrap();
[31m-        
(B[m[32m+
(B[m         match op {
[31m-            Op::Match { value, cases, default } => {
(B[m[32m+            Op::Match {
(B[m[32m+                value,
(B[m[32m+                cases,
(B[m[32m+                default,
(B[m[32m+            } => {
(B[m                 assert_eq!(value.len(), 1);
                 assert_eq!(cases.len(), 2);
                 assert!(default.is_some());
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:109:
[31m-                
(B[m[32m+
(B[m                 // Check case values
                 assert_eq!(cases[0].0, 1.0);
                 assert_eq!(cases[1].0, 2.0);
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:113:
[31m-                
(B[m[32m+
(B[m                 // Check case blocks
                 assert_eq!(cases[0].1.len(), 1);
                 assert_eq!(cases[1].1.len(), 1);
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:117:
[31m-                
(B[m[32m+
(B[m                 // Check default block
                 let default_block = default.unwrap();
                 assert_eq!(default_block.len(), 1);
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:121:
[31m-            },
(B[m[32m+            }
(B[m             _ => panic!("Expected Match operation"),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:125:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_match_without_default() {
         let source = vec![
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:134:
             "    case 2:".to_string(),
             "        push 20".to_string(),
         ];
[31m-        
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let op = parse_match_block(&source, &mut current_line, pos).unwrap();
[31m-        
(B[m[32m+
(B[m         match op {
[31m-            Op::Match { value, cases, default } => {
(B[m[32m+            Op::Match {
(B[m[32m+                value,
(B[m[32m+                cases,
(B[m[32m+                default,
(B[m[32m+            } => {
(B[m                 assert_eq!(value.len(), 1);
                 assert_eq!(cases.len(), 2);
                 assert!(default.is_none());
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:148:
[31m-            },
(B[m[32m+            }
(B[m             _ => panic!("Expected Match operation"),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:152:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_match_without_value_block() {
         let source = vec![
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:157:
             "    case 1:".to_string(),
             "        push 10".to_string(),
         ];
[31m-        
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let result = parse_match_block(&source, &mut current_line, pos);
         assert!(result.is_err());
[31m-        
(B[m[32m+
(B[m         match result.unwrap_err() {
             CompilerError::MissingMatchValue(line, _) => {
                 assert_eq!(line, 1);
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:170:
[31m-            },
(B[m[32m+            }
(B[m             err => panic!("Expected MissingMatchValue error, got {:?}", err),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/match_block.rs:174:
[31m-} 
(B[m[32m+}
(B[m[32m+
(B[mDiff in /home/matt/dev/nano-cvm/src/compiler/mod.rs:3:
 
 // Sub-modules
 pub mod common;
[32m+pub mod function_block;
(B[m pub mod if_block;
[31m-pub mod while_block;
(B[m[32m+pub mod line_parser;
(B[m pub mod loop_block;
 pub mod match_block;
[31m-pub mod function_block;
(B[m[31m-pub mod line_parser;
(B[m[32m+pub mod while_block;
(B[m 
 // Re-export the parser functions
[31m-pub use line_parser::parse_line;
(B[m[32m+pub use function_block::parse_function_block;
(B[m pub use if_block::parse_if_block;
[31m-pub use while_block::parse_while_block;
(B[m[32m+pub use line_parser::parse_line;
(B[m pub use loop_block::parse_loop_block;
 pub use match_block::parse_match_block;
[31m-pub use function_block::parse_function_block;
(B[m[32m+pub use while_block::parse_while_block;
(B[m 
 // Add this at the end of the file, before the mod tests; line
 /// Standard library support
Diff in /home/matt/dev/nano-cvm/src/compiler/mod.rs:26:
 pub fn parse_dsl_with_stdlib(source: &str) -> Result<Vec<Op>, CompilerError> {
     // First load the standard library code
     let stdlib_code = stdlib::get_stdlib_code();
[31m-    
(B[m[32m+
(B[m     // Concatenate the standard library code with the user code
     let combined_code = format!("{}\n\n{}", stdlib_code, source);
[31m-    
(B[m[32m+
(B[m     // Parse the combined code
     parse_dsl(&combined_code)
 }
Diff in /home/matt/dev/nano-cvm/src/compiler/mod.rs:38:
 pub enum CompilerError {
     #[error("Unknown command: {0} at line {1}, column {2}")]
     UnknownCommand(String, usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Unknown block type: {0} at line {1}, column {2}")]
     UnknownBlockType(String, usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Invalid function definition: {0} at line {1}, column {2}")]
     InvalidFunctionDefinition(String, usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Invalid function definition format: {0} at line {1}, column {2}")]
     InvalidFunctionFormat(String, usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Function definition must start with 'def': {0} at line {1}, column {2}")]
     InvalidFunctionStart(String, usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Missing number for push at line {0}, column {1}")]
     MissingPushValue(usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Invalid number for push: {0} at line {1}, column {2}")]
     InvalidPushValue(String, usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Missing quotes for emit command at line {0}, column {1}")]
     MissingEmitQuotes(usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Invalid format for emitevent at line {0}, column {1}, expected: emitevent \"category\" \"message\"")]
     InvalidEmitEventFormat(usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Missing variable for {0} at line {1}, column {2}")]
     MissingVariable(String, usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Missing function name for call at line {0}, column {1}")]
     MissingFunctionName(usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Missing depth for assertequalstack at line {0}, column {1}")]
     MissingAssertDepth(usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Invalid depth for assertequalstack: {0} at line {1}, column {2}")]
     InvalidAssertDepth(String, usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Depth for assertequalstack must be at least 2 at line {0}, column {1}")]
     InsufficientAssertDepth(usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Invalid case value: {0} at line {1}, column {2}")]
     InvalidCaseValue(String, usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Match statement must have a value block at line {0}, column {1}")]
     MissingMatchValue(usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Invalid loop format: {0} at line {1}, column {2}")]
     InvalidLoopFormat(String, usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Invalid loop count: {0} at line {1}, column {2}")]
     InvalidLoopCount(String, usize, usize),
[31m-    
(B[m[32m+
(B[m     #[error("Unexpected end of file while parsing block at line {0}")]
     UnexpectedEOF(usize),
[31m-    
(B[m[32m+
(B[m     #[error("Invalid indentation level at line {0}")]
     InvalidIndentation(usize),
 }
Diff in /home/matt/dev/nano-cvm/src/compiler/mod.rs:124:
         }
 
         let pos = SourcePosition::new(current_line + 1, common::get_indent(line) + 1);
[31m-        
(B[m[32m+
(B[m         let op = if line.trim().ends_with(':') {
             if line.trim() == "if:" {
                 parse_if_block(&lines, &mut current_line, pos)?
Diff in /home/matt/dev/nano-cvm/src/compiler/mod.rs:137:
             } else if line.trim().starts_with("loop ") {
                 parse_loop_block(&lines, &mut current_line, pos)?
             } else {
[31m-                return Err(CompilerError::UnknownBlockType(line.trim().to_string(), pos.line, pos.column));
(B[m[32m+                return Err(CompilerError::UnknownBlockType(
(B[m[32m+                    line.trim().to_string(),
(B[m[32m+                    pos.line,
(B[m[32m+                    pos.column,
(B[m[32m+                ));
(B[m             }
         } else {
             parse_line(line, pos)?
Diff in /home/matt/dev/nano-cvm/src/compiler/mod.rs:153:
 }
 
 #[cfg(test)]
[31m-mod tests; 
(B[m[32m+mod tests;
(B[m[32m+
(B[mDiff in /home/matt/dev/nano-cvm/src/compiler/stdlib.rs:87:
     or
     and
     return
[31m-"#.to_string()
(B[m[31m-} 
(B[m[32m+"#
(B[m[32m+    .to_string()
(B[m[32m+}
(B[m[32m+
(B[mDiff in /home/matt/dev/nano-cvm/src/compiler/tests.rs:1:
 // Tests for the compiler module
[31m-// Individual sub-modules have their own tests 
(B[m[32m+// Individual sub-modules have their own tests
(B[m[32m+
(B[mDiff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:1:
[32m+use super::{common, line_parser, CompilerError, SourcePosition};
(B[m use crate::vm::Op;
[31m-use super::{CompilerError, SourcePosition, common, line_parser};
(B[m 
 /// Parse a while statement block
[31m-pub fn parse_while_block(lines: &[String], current_line: &mut usize, pos: SourcePosition) -> Result<Op, CompilerError> {
(B[m[32m+pub fn parse_while_block(
(B[m[32m+    lines: &[String],
(B[m[32m+    current_line: &mut usize,
(B[m[32m+    pos: SourcePosition,
(B[m[32m+) -> Result<Op, CompilerError> {
(B[m     let mut condition = Vec::new();
     let mut body = Vec::new();
     let current_indent = common::get_indent(&lines[*current_line]);
Diff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:15:
     while *current_line < lines.len() {
         let line = &lines[*current_line];
         let indent = common::get_indent(line);
[31m-        
(B[m[32m+
(B[m         if indent <= current_indent {
             break;
         }
Diff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:25:
             has_explicit_condition = true;
             let condition_pos = SourcePosition::new(pos.line + *current_line, indent + 1);
             *current_line += 1;
[31m-            
(B[m[32m+
(B[m             // Parse condition block
             condition = line_parser::parse_block(lines, current_line, indent, condition_pos)?;
         } else if line.trim().ends_with(':') {
Diff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:32:
             // Handle nested block structures
             let nested_pos = SourcePosition::new(pos.line + *current_line, indent + 1);
[31m-            
(B[m[32m+
(B[m             if line.trim() == "if:" {
                 let nested_op = super::if_block::parse_if_block(lines, current_line, nested_pos)?;
                 body.push(nested_op);
Diff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:39:
                 let nested_op = parse_while_block(lines, current_line, nested_pos)?;
                 body.push(nested_op);
             } else if line.trim().starts_with("loop ") {
[31m-                let nested_op = super::loop_block::parse_loop_block(lines, current_line, nested_pos)?;
(B[m[32m+                let nested_op =
(B[m[32m+                    super::loop_block::parse_loop_block(lines, current_line, nested_pos)?;
(B[m                 body.push(nested_op);
             } else if line.trim() == "match:" {
[31m-                let nested_op = super::match_block::parse_match_block(lines, current_line, nested_pos)?;
(B[m[32m+                let nested_op =
(B[m[32m+                    super::match_block::parse_match_block(lines, current_line, nested_pos)?;
(B[m                 body.push(nested_op);
             } else {
[31m-                return Err(CompilerError::UnknownBlockType(line.trim().to_string(), nested_pos.line, nested_pos.column));
(B[m[32m+                return Err(CompilerError::UnknownBlockType(
(B[m[32m+                    line.trim().to_string(),
(B[m[32m+                    nested_pos.line,
(B[m[32m+                    nested_pos.column,
(B[m[32m+                ));
(B[m             }
         } else {
             // Regular statement in body
Diff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:64:
         condition = vec![body.remove(0)];
     }
 
[31m-    Ok(Op::While {
(B[m[31m-        condition,
(B[m[31m-        body,
(B[m[31m-    })
(B[m[32m+    Ok(Op::While { condition, body })
(B[m }
 
 #[cfg(test)]
Diff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:74:
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_while_block_parsing() {
         let source = vec![
Diff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:85:
             "    push 1".to_string(),
             "    sub".to_string(),
         ];
[31m-        
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let op = parse_while_block(&source, &mut current_line, pos).unwrap();
[31m-        
(B[m[32m+
(B[m         match op {
             Op::While { condition, body } => {
                 assert_eq!(condition.len(), 3);
Diff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:97:
                 assert_eq!(body.len(), 2);
[31m-            },
(B[m[32m+            }
(B[m             _ => panic!("Expected While operation"),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:102:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_nested_while_blocks() {
         let source = vec![
Diff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:110:
             "        push 1".to_string(),
             "        sub".to_string(),
         ];
[31m-        
(B[m[32m+
(B[m         let mut current_line = 0;
         let pos = SourcePosition::new(1, 1);
[31m-        
(B[m[32m+
(B[m         let op = parse_while_block(&source, &mut current_line, pos).unwrap();
[31m-        
(B[m[32m+
(B[m         match op {
             Op::While { condition, body } => {
                 assert_eq!(condition.len(), 1);
Diff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:122:
                 assert_eq!(body.len(), 1);
[31m-                
(B[m[32m+
(B[m                 // Check nested while
                 match &body[0] {
[31m-                    Op::While { condition: nested_condition, body: nested_body } => {
(B[m[32m+                    Op::While {
(B[m[32m+                        condition: nested_condition,
(B[m[32m+                        body: nested_body,
(B[m[32m+                    } => {
(B[m                         assert_eq!(nested_condition.len(), 1);
                         assert_eq!(nested_body.len(), 2);
[31m-                    },
(B[m[32m+                    }
(B[m                     _ => panic!("Expected nested While operation"),
                 }
[31m-            },
(B[m[32m+            }
(B[m             _ => panic!("Expected While operation"),
         }
     }
Diff in /home/matt/dev/nano-cvm/src/compiler/while_block.rs:136:
[31m-} 
(B[m[32m+}
(B[m[32m+
(B[mDiff in /home/matt/dev/nano-cvm/src/events.rs:1:
 use chrono::{DateTime, Utc};
[32m+use once_cell::sync::Lazy;
(B[m use serde::{Deserialize, Serialize};
 use std::fs::{File, OpenOptions};
 use std::io::{self, Write};
Diff in /home/matt/dev/nano-cvm/src/events.rs:5:
 use std::path::Path;
 use std::sync::Mutex;
[31m-use once_cell::sync::Lazy;
(B[m 
 #[derive(Debug, Clone, Serialize, Deserialize)]
 pub struct Event {
Diff in /home/matt/dev/nano-cvm/src/events.rs:11:
[31m-    pub level: String,     // "info", "warn", "error"
(B[m[31m-    pub tag: String,       // e.g., "emit", "stack", "memory", "governance"
(B[m[32m+    pub level: String, // "info", "warn", "error"
(B[m[32m+    pub tag: String,   // e.g., "emit", "stack", "memory", "governance"
(B[m     pub message: String,
     pub timestamp: String,
     #[serde(skip_serializing_if = "Option::is_none")]
Diff in /home/matt/dev/nano-cvm/src/events.rs:26:
 static LOG_FILE: Lazy<Mutex<Option<String>>> = Lazy::new(|| Mutex::new(None));
 
 impl Event {
[31m-    pub fn new<S1: Into<String>, S2: Into<String>, S3: Into<String>>(level: S1, tag: S2, message: S3) -> Self {
(B[m[32m+    pub fn new<S1: Into<String>, S2: Into<String>, S3: Into<String>>(
(B[m[32m+        level: S1,
(B[m[32m+        tag: S2,
(B[m[32m+        message: S3,
(B[m[32m+    ) -> Self {
(B[m         let now: DateTime<Utc> = Utc::now();
[31m-        
(B[m[32m+
(B[m         Self {
             level: level.into(),
             tag: tag.into(),
Diff in /home/matt/dev/nano-cvm/src/events.rs:37:
             data: None,
         }
     }
[31m-    
(B[m[32m+
(B[m     pub fn with_data(mut self, data: serde_json::Value) -> Self {
         self.data = Some(data);
         self
Diff in /home/matt/dev/nano-cvm/src/events.rs:44:
     }
[31m-    
(B[m[32m+
(B[m     pub fn info<S1: Into<String>, S2: Into<String>>(tag: S1, message: S2) -> Self {
         Self::new("info", tag, message)
     }
Diff in /home/matt/dev/nano-cvm/src/events.rs:49:
[31m-    
(B[m[32m+
(B[m     pub fn warn<S1: Into<String>, S2: Into<String>>(tag: S1, message: S2) -> Self {
         Self::new("warn", tag, message)
     }
Diff in /home/matt/dev/nano-cvm/src/events.rs:53:
[31m-    
(B[m[32m+
(B[m     pub fn error<S1: Into<String>, S2: Into<String>>(tag: S1, message: S2) -> Self {
         Self::new("error", tag, message)
     }
Diff in /home/matt/dev/nano-cvm/src/events.rs:57:
[31m-    
(B[m[32m+
(B[m     pub fn emit(&self) -> io::Result<()> {
         let format = LOG_FORMAT.lock().unwrap();
         let log_file = LOG_FILE.lock().unwrap().clone();
Diff in /home/matt/dev/nano-cvm/src/events.rs:61:
[31m-        
(B[m[32m+
(B[m         match *format {
             LogFormat::Pretty => self.emit_pretty(log_file),
             LogFormat::Json => self.emit_json(log_file),
Diff in /home/matt/dev/nano-cvm/src/events.rs:65:
         }
     }
[31m-    
(B[m[32m+
(B[m     fn emit_pretty(&self, log_file: Option<String>) -> io::Result<()> {
         let level_color = match self.level.as_str() {
[31m-            "info" => "\x1b[32m", // Green
(B[m[31m-            "warn" => "\x1b[33m", // Yellow
(B[m[32m+            "info" => "\x1b[32m",  // Green
(B[m[32m+            "warn" => "\x1b[33m",  // Yellow
(B[m             "error" => "\x1b[31m", // Red
[31m-            _ => "\x1b[0m",       // Default
(B[m[32m+            _ => "\x1b[0m",        // Default
(B[m         };
[31m-        
(B[m[32m+
(B[m         let pretty_line = format!(
[31m-            "{}{} [{}] [{}] {}\x1b[0m", 
(B[m[32m+            "{}{} [{}] [{}] {}\x1b[0m",
(B[m             level_color,
[31m-            self.timestamp.split('T').nth(1).unwrap_or(&self.timestamp).split('.').next().unwrap_or(""),
(B[m[31m-            self.level.to_uppercase(), 
(B[m[32m+            self.timestamp
(B[m[32m+                .split('T')
(B[m[32m+                .nth(1)
(B[m[32m+                .unwrap_or(&self.timestamp)
(B[m[32m+                .split('.')
(B[m[32m+                .next()
(B[m[32m+                .unwrap_or(""),
(B[m[32m+            self.level.to_uppercase(),
(B[m             self.tag,
             self.message
         );
Diff in /home/matt/dev/nano-cvm/src/events.rs:84:
[31m-        
(B[m[32m+
(B[m         // Always print to stdout
         println!("{}", pretty_line);
[31m-        
(B[m[32m+
(B[m         // If log file is specified, write to it
         if let Some(file_path) = log_file {
             let plain_line = format!(
Diff in /home/matt/dev/nano-cvm/src/events.rs:91:
[31m-                "{} [{}] [{}] {}", 
(B[m[31m-                self.timestamp, 
(B[m[31m-                self.level.to_uppercase(), 
(B[m[32m+                "{} [{}] [{}] {}",
(B[m[32m+                self.timestamp,
(B[m[32m+                self.level.to_uppercase(),
(B[m                 self.tag,
                 self.message
             );
Diff in /home/matt/dev/nano-cvm/src/events.rs:97:
[31m-            
(B[m[32m+
(B[m             append_to_file(&file_path, &plain_line)?;
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     fn emit_json(&self, log_file: Option<String>) -> io::Result<()> {
         let json = serde_json::to_string(&self).unwrap();
[31m-        
(B[m[32m+
(B[m         // Always print to stdout
         println!("{}", json);
[31m-        
(B[m[32m+
(B[m         // If log file is specified, write to it
         if let Some(file_path) = log_file {
             append_to_file(&file_path, &json)?;
Diff in /home/matt/dev/nano-cvm/src/events.rs:113:
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /home/matt/dev/nano-cvm/src/events.rs:128:
 
 fn append_to_file(file_path: &str, content: &str) -> io::Result<()> {
     let path = Path::new(file_path);
[31m-    
(B[m[32m+
(B[m     // Create parent directories if they don't exist
     if let Some(parent) = path.parent() {
         if !parent.exists() {
Diff in /home/matt/dev/nano-cvm/src/events.rs:135:
             std::fs::create_dir_all(parent)?;
         }
     }
[31m-    
(B[m[32m+
(B[m     // Open file with append mode
[31m-    let mut file = OpenOptions::new()
(B[m[31m-        .create(true)
(B[m[31m-        .append(true)
(B[m[31m-        .open(path)?;
(B[m[31m-    
(B[m[32m+    let mut file = OpenOptions::new().create(true).append(true).open(path)?;
(B[m[32m+
(B[m     // Write content with newline
     writeln!(file, "{}", content)?;
[31m-    
(B[m[32m+
(B[m     Ok(())
[31m-} 
(B[m[32m+}
(B[m[32m+
(B[mDiff in /home/matt/dev/nano-cvm/src/main.rs:1:
[31m-mod vm;
(B[m mod compiler;
 mod events;
[31m-use std::fs;
(B[m[31m-use std::path::Path;
(B[m[31m-use vm::{Op, VM, VMError};
(B[m[32m+mod vm;
(B[m[32m+use clap::{Arg, Command};
(B[m use compiler::{parse_dsl, parse_dsl_with_stdlib, CompilerError};
 use events::Event;
[31m-use clap::{Arg, Command};
(B[m use serde_json;
[31m-use std::process;
(B[m[32m+use std::collections::HashMap;
(B[m use std::error::Error;
[32m+use std::fs;
(B[m[32m+use std::path::Path;
(B[m[32m+use std::process;
(B[m use thiserror::Error;
[31m-use std::collections::HashMap;
(B[m[32m+use vm::{Op, VMError, VM};
(B[m 
 #[derive(Debug, Error)]
 enum AppError {
Diff in /home/matt/dev/nano-cvm/src/main.rs:49:
         .version("0.2.0")
         .author("Intercooperative Network")
         .about("Secure stack-based virtual machine with governance-inspired opcodes")
[31m-        .arg(Arg::new("program")
(B[m[31m-            .short('p')
(B[m[31m-            .long("program")
(B[m[31m-            .value_name("FILE")
(B[m[31m-            .help("Program file to execute (.dsl or .json)")
(B[m[31m-            .default_value("program.dsl"))
(B[m[31m-        .arg(Arg::new("verbose")
(B[m[31m-            .short('v')
(B[m[31m-            .long("verbose")
(B[m[31m-            .help("Display detailed execution information")
(B[m[31m-            .action(clap::ArgAction::SetTrue))
(B[m[31m-        .arg(Arg::new("param")
(B[m[31m-            .short('P')
(B[m[31m-            .long("param")
(B[m[31m-            .value_name("KEY=VALUE")
(B[m[31m-            .help("Set a key-value parameter for the program (can be used multiple times)")
(B[m[31m-            .action(clap::ArgAction::Append))
(B[m[31m-        .arg(Arg::new("interactive")
(B[m[31m-            .short('i')
(B[m[31m-            .long("interactive")
(B[m[31m-            .help("Start in interactive REPL mode")
(B[m[31m-            .action(clap::ArgAction::SetTrue))
(B[m[31m-        .arg(Arg::new("json")
(B[m[31m-            .long("json")
(B[m[31m-            .help("Output logs in JSON format")
(B[m[31m-            .action(clap::ArgAction::SetTrue))
(B[m[31m-        .arg(Arg::new("stdlib")
(B[m[31m-            .long("stdlib")
(B[m[31m-            .help("Include standard library functions")
(B[m[31m-            .action(clap::ArgAction::SetTrue))
(B[m[32m+        .arg(
(B[m[32m+            Arg::new("program")
(B[m[32m+                .short('p')
(B[m[32m+                .long("program")
(B[m[32m+                .value_name("FILE")
(B[m[32m+                .help("Program file to execute (.dsl or .json)")
(B[m[32m+                .default_value("program.dsl"),
(B[m[32m+        )
(B[m[32m+        .arg(
(B[m[32m+            Arg::new("verbose")
(B[m[32m+                .short('v')
(B[m[32m+                .long("verbose")
(B[m[32m+                .help("Display detailed execution information")
(B[m[32m+                .action(clap::ArgAction::SetTrue),
(B[m[32m+        )
(B[m[32m+        .arg(
(B[m[32m+            Arg::new("param")
(B[m[32m+                .short('P')
(B[m[32m+                .long("param")
(B[m[32m+                .value_name("KEY=VALUE")
(B[m[32m+                .help("Set a key-value parameter for the program (can be used multiple times)")
(B[m[32m+                .action(clap::ArgAction::Append),
(B[m[32m+        )
(B[m[32m+        .arg(
(B[m[32m+            Arg::new("interactive")
(B[m[32m+                .short('i')
(B[m[32m+                .long("interactive")
(B[m[32m+                .help("Start in interactive REPL mode")
(B[m[32m+                .action(clap::ArgAction::SetTrue),
(B[m[32m+        )
(B[m[32m+        .arg(
(B[m[32m+            Arg::new("json")
(B[m[32m+                .long("json")
(B[m[32m+                .help("Output logs in JSON format")
(B[m[32m+                .action(clap::ArgAction::SetTrue),
(B[m[32m+        )
(B[m[32m+        .arg(
(B[m[32m+            Arg::new("stdlib")
(B[m[32m+                .long("stdlib")
(B[m[32m+                .help("Include standard library functions")
(B[m[32m+                .action(clap::ArgAction::SetTrue),
(B[m[32m+        )
(B[m         .get_matches();
 
     // Get program file and verbosity setting
Diff in /home/matt/dev/nano-cvm/src/main.rs:85:
     let program_path = matches.get_one::<String>("program").unwrap();
     let verbose = matches.get_flag("verbose");
     let interactive = matches.get_flag("interactive");
[31m-    
(B[m[32m+
(B[m     // Collect parameters
     let mut parameters = HashMap::new();
     if let Some(params) = matches.get_many::<String>("param") {
Diff in /home/matt/dev/nano-cvm/src/main.rs:92:
         for param_str in params {
             if let Some(equals_pos) = param_str.find('=') {
                 let key = param_str[0..equals_pos].to_string();
[31m-                let value = param_str[equals_pos+1..].to_string();
(B[m[32m+                let value = param_str[equals_pos + 1..].to_string();
(B[m                 if verbose {
                     println!("Parameter: {} = {}", key, value);
                 }
Diff in /home/matt/dev/nano-cvm/src/main.rs:99:
                 parameters.insert(key, value);
             } else {
[31m-                eprintln!("Warning: Invalid parameter format '{}', expected KEY=VALUE", param_str);
(B[m[32m+                eprintln!(
(B[m[32m+                    "Warning: Invalid parameter format '{}', expected KEY=VALUE",
(B[m[32m+                    param_str
(B[m[32m+                );
(B[m             }
         }
     }
Diff in /home/matt/dev/nano-cvm/src/main.rs:118:
     }
 }
 
[31m-fn run_program(program_path: &str, verbose: bool, use_stdlib: bool, parameters: HashMap<String, String>) -> Result<(), AppError> {
(B[m[32m+fn run_program(
(B[m[32m+    program_path: &str,
(B[m[32m+    verbose: bool,
(B[m[32m+    use_stdlib: bool,
(B[m[32m+    parameters: HashMap<String, String>,
(B[m[32m+) -> Result<(), AppError> {
(B[m     let path = Path::new(program_path);
[31m-    
(B[m[32m+
(B[m     // Check if file exists
     if !path.exists() {
         return Err(format!("Program file not found: {}", program_path).into());
Diff in /home/matt/dev/nano-cvm/src/main.rs:127:
     }
[31m-    
(B[m[32m+
(B[m     // Parse operations based on file extension
     let ops = if let Some(extension) = path.extension().and_then(|e| e.to_str()) {
         match extension.to_lowercase().as_str() {
Diff in /home/matt/dev/nano-cvm/src/main.rs:134:
                     println!("Parsing DSL program from {}", program_path);
                 }
                 let program_source = fs::read_to_string(path)?;
[31m-                
(B[m[32m+
(B[m                 // Check if we should include the standard library
                 if verbose && use_stdlib {
                     println!("Including standard library functions");
Diff in /home/matt/dev/nano-cvm/src/main.rs:141:
                 }
[31m-                
(B[m[32m+
(B[m                 if use_stdlib {
                     parse_dsl_with_stdlib(&program_source)?
                 } else {
Diff in /home/matt/dev/nano-cvm/src/main.rs:146:
                     parse_dsl(&program_source)?
                 }
[31m-            },
(B[m[32m+            }
(B[m             "json" => {
                 if verbose {
                     println!("Parsing JSON program from {}", program_path);
Diff in /home/matt/dev/nano-cvm/src/main.rs:152:
                 }
                 let program_json = fs::read_to_string(path)?;
                 serde_json::from_str(&program_json)?
[31m-            },
(B[m[31m-            _ => return Err(format!("Unsupported file extension: {}", extension).into())
(B[m[32m+            }
(B[m[32m+            _ => return Err(format!("Unsupported file extension: {}", extension).into()),
(B[m         }
     } else {
         return Err("File has no extension".into());
Diff in /home/matt/dev/nano-cvm/src/main.rs:160:
     };
[31m-    
(B[m[32m+
(B[m     if verbose {
         println!("Program loaded with {} operations", ops.len());
     }
Diff in /home/matt/dev/nano-cvm/src/main.rs:165:
 
     // Create and execute the VM
     let mut vm = VM::new();
[31m-    
(B[m[32m+
(B[m     // Set parameters
     vm.set_parameters(parameters)?;
[31m-    
(B[m[32m+
(B[m     if verbose {
         println!("Executing program...");
         println!("-----------------------------------");
Diff in /home/matt/dev/nano-cvm/src/main.rs:175:
     }
[31m-    
(B[m[32m+
(B[m     vm.execute(&ops)?;
[31m-    
(B[m[32m+
(B[m     if verbose {
         println!("-----------------------------------");
         println!("Program execution completed successfully");
Diff in /home/matt/dev/nano-cvm/src/main.rs:191:
 }
 
 fn run_interactive(verbose: bool, parameters: HashMap<String, String>) -> Result<(), AppError> {
[31m-    use std::io::{self, Write, BufRead};
(B[m[31m-    
(B[m[32m+    use std::io::{self, BufRead, Write};
(B[m[32m+
(B[m     println!("nano-cvm interactive mode");
     println!("Enter commands in DSL format, 'help' for available commands, 'exit' to quit");
[31m-    
(B[m[32m+
(B[m     let mut vm = VM::new();
     vm.set_parameters(parameters)?;
[31m-    
(B[m[32m+
(B[m     // Show initial parameters if any
     if !vm.get_memory_map().is_empty() {
         println!("Initial parameters:");
Diff in /home/matt/dev/nano-cvm/src/main.rs:206:
             println!("  {}: {}", key, value);
         }
     }
[31m-    
(B[m[32m+
(B[m     let stdin = io::stdin();
     let mut handle = stdin.lock();
     let mut buffer = String::new();
Diff in /home/matt/dev/nano-cvm/src/main.rs:213:
[31m-    
(B[m[32m+
(B[m     loop {
         print!("> ");
         io::stdout().flush()?;
Diff in /home/matt/dev/nano-cvm/src/main.rs:217:
[31m-        
(B[m[32m+
(B[m         buffer.clear();
         handle.read_line(&mut buffer)?;
[31m-        
(B[m[32m+
(B[m         let input = buffer.trim();
[31m-        
(B[m[32m+
(B[m         match input {
             "exit" | "quit" => {
                 println!("Exiting interactive mode");
Diff in /home/matt/dev/nano-cvm/src/main.rs:226:
                 break;
[31m-            },
(B[m[32m+            }
(B[m             "help" => {
                 println!("Available commands:");
                 println!("  push <number>     - Push a number onto the stack");
Diff in /home/matt/dev/nano-cvm/src/main.rs:235:
                 println!("  dup               - Duplicate the top value on the stack");
                 println!("  swap              - Swap the top two values on the stack");
                 println!("  emit \"message\"    - Output a message");
[31m-                println!("  store <key>       - Store the top stack value in memory with the given key");
(B[m[32m+                println!(
(B[m[32m+                    "  store <key>       - Store the top stack value in memory with the given key"
(B[m[32m+                );
(B[m                 println!("  load <key>        - Load a value from memory with the given key");
                 println!("  dump_stack        - Display the current stack");
                 println!("  dump_memory       - Display the current memory");
Diff in /home/matt/dev/nano-cvm/src/main.rs:242:
                 println!("  exit, quit        - Exit the interactive mode");
[31m-            },
(B[m[32m+            }
(B[m             "dump_stack" => {
                 println!("Stack:");
                 for (i, &value) in vm.get_stack().iter().enumerate() {
Diff in /home/matt/dev/nano-cvm/src/main.rs:247:
                     println!("  {}: {}", i, value);
                 }
[31m-            },
(B[m[32m+            }
(B[m             "dump_memory" => {
                 println!("Memory:");
                 for (key, &value) in vm.get_memory_map().iter() {
Diff in /home/matt/dev/nano-cvm/src/main.rs:253:
                     println!("  {}: {}", key, value);
                 }
[31m-            },
(B[m[32m+            }
(B[m             _ => {
                 // Try to parse and execute the input as DSL
                 if !input.is_empty() {
Diff in /home/matt/dev/nano-cvm/src/main.rs:261:
                             if verbose {
                                 println!("Executing {} operation(s)", ops.len());
                             }
[31m-                            
(B[m[32m+
(B[m                             if let Err(err) = vm.execute(&ops) {
                                 println!("Error executing operations: {}", err);
                             } else if verbose {
Diff in /home/matt/dev/nano-cvm/src/main.rs:268:
                                 println!("Operation(s) executed successfully");
[31m-                                
(B[m[32m+
(B[m                                 println!("Stack:");
                                 for (i, &value) in vm.get_stack().iter().enumerate() {
                                     println!("  {}: {}", i, value);
Diff in /home/matt/dev/nano-cvm/src/main.rs:273:
                                 }
                             }
[31m-                        },
(B[m[32m+                        }
(B[m                         Err(err) => {
                             println!("Error parsing input: {}", err);
                         }
Diff in /home/matt/dev/nano-cvm/src/main.rs:281:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     Ok(())
 }
 
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1:
[32m+use crate::events::Event;
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 use thiserror::Error;
Diff in /home/matt/dev/nano-cvm/src/vm.rs:4:
[31m-use crate::events::Event;
(B[m 
 #[derive(Debug, Error, Clone, PartialEq)]
 pub enum VMError {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:8:
     #[error("Stack underflow in {op}: needed {needed}, found {found}")]
[31m-    StackUnderflow { op: String, needed: usize, found: usize },
(B[m[31m-    
(B[m[32m+    StackUnderflow {
(B[m[32m+        op: String,
(B[m[32m+        needed: usize,
(B[m[32m+        found: usize,
(B[m[32m+    },
(B[m[32m+
(B[m     #[error("Division by zero")]
     DivisionByZero,
[31m-    
(B[m[32m+
(B[m     #[error("Variable not found: {0}")]
     VariableNotFound(String),
[31m-    
(B[m[32m+
(B[m     #[error("Function not found: {0}")]
     FunctionNotFound(String),
[31m-    
(B[m[32m+
(B[m     #[error("Maximum recursion depth exceeded")]
     MaxRecursionDepth,
[31m-    
(B[m[32m+
(B[m     #[error("Invalid condition: {0}")]
     InvalidCondition(String),
[31m-    
(B[m[32m+
(B[m     #[error("Assertion failed: expected {expected}, found {found}")]
     AssertionFailed { expected: f64, found: f64 },
[31m-    
(B[m[32m+
(B[m     #[error("IO error: {0}")]
     IOError(String),
[31m-    
(B[m[32m+
(B[m     #[error("REPL error: {0}")]
     ReplError(String),
[31m-    
(B[m[32m+
(B[m     #[error("Parameter error: {0}")]
     ParameterError(String),
 }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:46:
     Mod,
     Store(String),
     Load(String),
[31m-    If { condition: Vec<Op>, then: Vec<Op>, else_: Option<Vec<Op>> },
(B[m[31m-    Loop { count: usize, body: Vec<Op> },
(B[m[31m-    While { condition: Vec<Op>, body: Vec<Op> },
(B[m[32m+    If {
(B[m[32m+        condition: Vec<Op>,
(B[m[32m+        then: Vec<Op>,
(B[m[32m+        else_: Option<Vec<Op>>,
(B[m[32m+    },
(B[m[32m+    Loop {
(B[m[32m+        count: usize,
(B[m[32m+        body: Vec<Op>,
(B[m[32m+    },
(B[m[32m+    While {
(B[m[32m+        condition: Vec<Op>,
(B[m[32m+        body: Vec<Op>,
(B[m[32m+    },
(B[m     Emit(String),
     Negate,
     AssertTop(f64),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:55:
     DumpStack,
     DumpMemory,
[31m-    AssertMemory { key: String, expected: f64 },
(B[m[32m+    AssertMemory {
(B[m[32m+        key: String,
(B[m[32m+        expected: f64,
(B[m[32m+    },
(B[m     Pop,
     Eq,
     Gt,
Diff in /home/matt/dev/nano-cvm/src/vm.rs:65:
     Dup,
     Swap,
     Over,
[31m-    Def { name: String, params: Vec<String>, body: Vec<Op> },
(B[m[32m+    Def {
(B[m[32m+        name: String,
(B[m[32m+        params: Vec<String>,
(B[m[32m+        body: Vec<Op>,
(B[m[32m+    },
(B[m     Call(String),
     Return,
     Nop,
Diff in /home/matt/dev/nano-cvm/src/vm.rs:72:
     // New governance-inspired opcodes
[31m-    Match { value: Vec<Op>, cases: Vec<(f64, Vec<Op>)>, default: Option<Vec<Op>> },
(B[m[32m+    Match {
(B[m[32m+        value: Vec<Op>,
(B[m[32m+        cases: Vec<(f64, Vec<Op>)>,
(B[m[32m+        default: Option<Vec<Op>>,
(B[m[32m+    },
(B[m     Break,
     Continue,
[31m-    EmitEvent { category: String, message: String },
(B[m[31m-    AssertEqualStack { depth: usize },
(B[m[32m+    EmitEvent {
(B[m[32m+        category: String,
(B[m[32m+        message: String,
(B[m[32m+    },
(B[m[32m+    AssertEqualStack {
(B[m[32m+        depth: usize,
(B[m[32m+    },
(B[m     // Debug/introspection opcode
     DumpState,
 }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:137:
                     // For non-numeric strings, we'll store the length as a numeric value
                     // This allows parameters to be used in the stack machine
                     self.memory.insert(key.clone(), value.len() as f64);
[31m-                    
(B[m[32m+
(B[m                     // Also log this for debugging
                     let event = Event::info(
[31m-                        "params", 
(B[m[31m-                        &format!("Parameter '{}' is not numeric, storing length {}", key, value.len())
(B[m[32m+                        "params",
(B[m[32m+                        &format!(
(B[m[32m+                            "Parameter '{}' is not numeric, storing length {}",
(B[m[32m+                            key,
(B[m[32m+                            value.len()
(B[m[32m+                        ),
(B[m                     );
                     event.emit().map_err(|e| VMError::IOError(e.to_string()))?;
                 }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:159:
 
     // Helper for stack operations that need to pop one value
     fn pop_one(&mut self, op_name: &str) -> Result<f64, VMError> {
[31m-        self.stack.pop().ok_or_else(|| VMError::StackUnderflow { 
(B[m[31m-            op: op_name.to_string(), 
(B[m[31m-            needed: 1, 
(B[m[31m-            found: 0 
(B[m[32m+        self.stack.pop().ok_or_else(|| VMError::StackUnderflow {
(B[m[32m+            op: op_name.to_string(),
(B[m[32m+            needed: 1,
(B[m[32m+            found: 0,
(B[m         })
     }
 
Diff in /home/matt/dev/nano-cvm/src/vm.rs:169:
     // Helper for stack operations that need to pop two values
     fn pop_two(&mut self, op_name: &str) -> Result<(f64, f64), VMError> {
         if self.stack.len() < 2 {
[31m-            return Err(VMError::StackUnderflow { 
(B[m[31m-                op: op_name.to_string(), 
(B[m[31m-                needed: 2, 
(B[m[31m-                found: self.stack.len() 
(B[m[32m+            return Err(VMError::StackUnderflow {
(B[m[32m+                op: op_name.to_string(),
(B[m[32m+                needed: 2,
(B[m[32m+                found: self.stack.len(),
(B[m             });
         }
         let b = self.stack.pop().unwrap();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:191:
             if self.loop_control != LoopControl::None {
                 break;
             }
[31m-            
(B[m[32m+
(B[m             let op = &ops[pc];
             match op {
                 Op::Push(value) => {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:201:
                     self.pop_one("Pop")?;
                 }
                 Op::Dup => {
[31m-                    let value = self.stack.last().ok_or_else(|| VMError::StackUnderflow { 
(B[m[31m-                        op: "Dup".to_string(), 
(B[m[31m-                        needed: 1, 
(B[m[31m-                        found: 0 
(B[m[32m+                    let value = self.stack.last().ok_or_else(|| VMError::StackUnderflow {
(B[m[32m+                        op: "Dup".to_string(),
(B[m[32m+                        needed: 1,
(B[m[32m+                        found: 0,
(B[m                     })?;
                     self.stack.push(*value);
                 }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:211:
                 Op::Swap => {
                     if self.stack.len() < 2 {
[31m-                        return Err(VMError::StackUnderflow { 
(B[m[31m-                            op: "Swap".to_string(), 
(B[m[31m-                            needed: 2, 
(B[m[31m-                            found: self.stack.len()
(B[m[32m+                        return Err(VMError::StackUnderflow {
(B[m[32m+                            op: "Swap".to_string(),
(B[m[32m+                            needed: 2,
(B[m[32m+                            found: self.stack.len(),
(B[m                         });
                     }
                     let len = self.stack.len();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:221:
                 }
                 Op::Over => {
                     if self.stack.len() < 2 {
[31m-                        return Err(VMError::StackUnderflow { 
(B[m[31m-                            op: "Over".to_string(), 
(B[m[31m-                            needed: 2, 
(B[m[31m-                            found: self.stack.len()
(B[m[32m+                        return Err(VMError::StackUnderflow {
(B[m[32m+                            op: "Over".to_string(),
(B[m[32m+                            needed: 2,
(B[m[32m+                            found: self.stack.len(),
(B[m                         });
                     }
                     let value = self.stack[self.stack.len() - 2];
Diff in /home/matt/dev/nano-cvm/src/vm.rs:262:
                 }
                 Op::Eq => {
                     let (a, b) = self.pop_two("Eq")?;
[31m-                    self.stack.push(if (a - b).abs() < f64::EPSILON { 0.0 } else { 1.0 });
(B[m[32m+                    self.stack.push(if (a - b).abs() < f64::EPSILON {
(B[m[32m+                        0.0
(B[m[32m+                    } else {
(B[m[32m+                        1.0
(B[m[32m+                    });
(B[m                 }
                 Op::Lt => {
                     let (a, b) = self.pop_two("Lt")?;
Diff in /home/matt/dev/nano-cvm/src/vm.rs:278:
                 }
                 Op::And => {
                     let (a, b) = self.pop_two("And")?;
[31m-                    self.stack.push(if a != 0.0 && b != 0.0 { 1.0 } else { 0.0 });
(B[m[32m+                    self.stack
(B[m[32m+                        .push(if a != 0.0 && b != 0.0 { 1.0 } else { 0.0 });
(B[m                 }
                 Op::Or => {
                     let (a, b) = self.pop_two("Or")?;
Diff in /home/matt/dev/nano-cvm/src/vm.rs:285:
[31m-                    self.stack.push(if a != 0.0 || b != 0.0 { 1.0 } else { 0.0 });
(B[m[32m+                    self.stack
(B[m[32m+                        .push(if a != 0.0 || b != 0.0 { 1.0 } else { 0.0 });
(B[m                 }
                 Op::Store(key) => {
                     let value = self.pop_one("Store")?;
Diff in /home/matt/dev/nano-cvm/src/vm.rs:289:
[31m-                    
(B[m[32m+
(B[m                     // We need to store in the current function's memory if we're in a function call
                     if !self.call_frames.is_empty() {
                         // Store in the current call frame
Diff in /home/matt/dev/nano-cvm/src/vm.rs:293:
[31m-                        self.call_frames.last_mut().unwrap().memory.insert(key.clone(), value);
(B[m[32m+                        self.call_frames
(B[m[32m+                            .last_mut()
(B[m[32m+                            .unwrap()
(B[m[32m+                            .memory
(B[m[32m+                            .insert(key.clone(), value);
(B[m                     } else {
                         // Otherwise store in global memory
                         self.memory.insert(key.clone(), value);
Diff in /home/matt/dev/nano-cvm/src/vm.rs:304:
                             *value
                         } else {
                             // If not found in function memory, check global memory
[31m-                            *self.memory.get(key).ok_or_else(|| VMError::VariableNotFound(key.clone()))?
(B[m[32m+                            *self
(B[m[32m+                                .memory
(B[m[32m+                                .get(key)
(B[m[32m+                                .ok_or_else(|| VMError::VariableNotFound(key.clone()))?
(B[m                         }
                     } else {
                         // If not in a function, just use global memory
Diff in /home/matt/dev/nano-cvm/src/vm.rs:311:
[31m-                        *self.memory.get(key).ok_or_else(|| VMError::VariableNotFound(key.clone()))?
(B[m[32m+                        *self
(B[m[32m+                            .memory
(B[m[32m+                            .get(key)
(B[m[32m+                            .ok_or_else(|| VMError::VariableNotFound(key.clone()))?
(B[m                     };
[31m-                    
(B[m[32m+
(B[m                     self.stack.push(value);
                 }
                 Op::DumpStack => {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:334:
                     event.emit().map_err(|e| VMError::IOError(e.to_string()))?;
                 }
                 Op::Def { name, params, body } => {
[31m-                    self.functions.insert(name.clone(), (params.clone(), body.clone()));
(B[m[32m+                    self.functions
(B[m[32m+                        .insert(name.clone(), (params.clone(), body.clone()));
(B[m                 }
[31m-                
(B[m[32m+
(B[m                 Op::Loop { count, body } => {
                     for _i in 0..*count {
                         self.execute_inner(body)?;
Diff in /home/matt/dev/nano-cvm/src/vm.rs:343:
[31m-                        
(B[m[32m+
(B[m                         // Handle loop control flow
                         match self.loop_control {
                             LoopControl::Break => {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:347:
                                 self.loop_control = LoopControl::None;
                                 break;
[31m-                            },
(B[m[32m+                            }
(B[m                             LoopControl::Continue => {
                                 self.loop_control = LoopControl::None;
                                 continue;
Diff in /home/matt/dev/nano-cvm/src/vm.rs:353:
[31m-                            },
(B[m[32m+                            }
(B[m                             LoopControl::None => {}
                         }
                     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:357:
                 }
[31m-                
(B[m[32m+
(B[m                 Op::While { condition, body } => {
                     if condition.is_empty() {
                         return Err(VMError::InvalidCondition(
Diff in /home/matt/dev/nano-cvm/src/vm.rs:362:
[31m-                            "While condition block cannot be empty".to_string()
(B[m[32m+                            "While condition block cannot be empty".to_string(),
(B[m                         ));
                     }
 
Diff in /home/matt/dev/nano-cvm/src/vm.rs:366:
                     loop {
                         // Execute the condition code
                         self.execute_inner(condition)?;
[31m-                        
(B[m[32m+
(B[m                         // Get the result of the condition
                         let cond = self.pop_one("While condition")?;
[31m-                        
(B[m[32m+
(B[m                         // If condition is true (0.0), execute the body
                         // If condition is false (non-zero), exit the loop
                         if cond != 0.0 {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:376:
                             break;
                         }
[31m-                        
(B[m[32m+
(B[m                         // Execute the body code
                         self.execute_inner(body)?;
[31m-                        
(B[m[32m+
(B[m                         // Handle loop control flow
                         match self.loop_control {
                             LoopControl::Break => {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:385:
                                 self.loop_control = LoopControl::None;
                                 break;
[31m-                            },
(B[m[32m+                            }
(B[m                             LoopControl::Continue => {
                                 self.loop_control = LoopControl::None;
                                 continue;
Diff in /home/matt/dev/nano-cvm/src/vm.rs:391:
[31m-                            },
(B[m[32m+                            }
(B[m                             LoopControl::None => {}
                         }
                     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:395:
                 }
[31m-                
(B[m[32m+
(B[m                 Op::Break => {
                     self.loop_control = LoopControl::Break;
                 }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:400:
[31m-                
(B[m[32m+
(B[m                 Op::Continue => {
                     self.loop_control = LoopControl::Continue;
                 }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:404:
[31m-                
(B[m[32m+
(B[m                 Op::EmitEvent { category, message } => {
                     let event = Event::info(category.as_str(), message.as_str());
                     event.emit().map_err(|e| VMError::IOError(e.to_string()))?;
Diff in /home/matt/dev/nano-cvm/src/vm.rs:408:
                 }
[31m-                
(B[m[32m+
(B[m                 Op::AssertEqualStack { depth } => {
                     if self.stack.len() < *depth {
                         return Err(VMError::StackUnderflow {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:415:
                             found: self.stack.len(),
                         });
                     }
[31m-                    
(B[m[32m+
(B[m                     let top_value = self.stack[self.stack.len() - 1];
                     for i in 1..*depth {
[31m-                        if (self.stack[self.stack.len() - 1 - i] - top_value).abs() >= f64::EPSILON {
(B[m[32m+                        if (self.stack[self.stack.len() - 1 - i] - top_value).abs() >= f64::EPSILON
(B[m[32m+                        {
(B[m                             return Err(VMError::AssertionFailed {
                                 expected: top_value,
                                 found: self.stack[self.stack.len() - 1 - i],
Diff in /home/matt/dev/nano-cvm/src/vm.rs:427:
                     }
                 }
 
[31m-                Op::If { condition, then, else_ } => {
(B[m[31m-                    // Get condition value 
(B[m[32m+                Op::If {
(B[m[32m+                    condition,
(B[m[32m+                    then,
(B[m[32m+                    else_,
(B[m[32m+                } => {
(B[m[32m+                    // Get condition value
(B[m                     let condition_value = if condition.is_empty() {
                         // If condition is empty, use the value already on the stack
                         if self.stack.is_empty() {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:435:
[31m-                            return Err(VMError::StackUnderflow { 
(B[m[31m-                                op: "If".to_string(), 
(B[m[31m-                                needed: 1, 
(B[m[31m-                                found: 0 
(B[m[32m+                            return Err(VMError::StackUnderflow {
(B[m[32m+                                op: "If".to_string(),
(B[m[32m+                                needed: 1,
(B[m[32m+                                found: 0,
(B[m                             });
                         }
                         self.pop_one("If condition")?
Diff in /home/matt/dev/nano-cvm/src/vm.rs:442:
                     } else {
                         // Save the stack size before executing the condition
                         let stack_size_before = self.stack.len();
[31m-                        
(B[m[32m+
(B[m                         // Execute the condition operations
                         self.execute_inner(condition)?;
[31m-                        
(B[m[32m+
(B[m                         // Make sure the stack has at least one more value than before
                         if self.stack.len() <= stack_size_before {
                             return Err(VMError::InvalidCondition(
Diff in /home/matt/dev/nano-cvm/src/vm.rs:452:
[31m-                                "Condition block did not leave a value on the stack".to_string()
(B[m[32m+                                "Condition block did not leave a value on the stack".to_string(),
(B[m                             ));
                         }
[31m-                        
(B[m[32m+
(B[m                         // Get the top value from the stack
                         self.pop_one("If condition result")?
                     };
Diff in /home/matt/dev/nano-cvm/src/vm.rs:468:
                         self.stack.push(condition_value);
                     }
                 }
[31m-                
(B[m[32m+
(B[m                 Op::Negate => {
                     let value = self.pop_one("Negate")?;
                     self.stack.push(-value);
Diff in /home/matt/dev/nano-cvm/src/vm.rs:475:
                 }
[31m-                
(B[m[32m+
(B[m                 Op::Call(name) => {
[31m-                    let (params, body) = self.functions.get(name)
(B[m[32m+                    let (params, body) = self
(B[m[32m+                        .functions
(B[m[32m+                        .get(name)
(B[m                         .ok_or_else(|| VMError::FunctionNotFound(name.clone()))?
                         .clone();
[31m-                    
(B[m[32m+
(B[m                     // Create a new call frame for function execution
                     let mut frame = CallFrame {
                         memory: HashMap::new(),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:485:
                         return_value: None,
                     };
[31m-                    
(B[m[32m+
(B[m                     // If there are named parameters, pop values for them from the stack
                     if !params.is_empty() {
                         if self.stack.len() < params.len() {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:494:
                                 found: self.stack.len(),
                             });
                         }
[31m-                        
(B[m[32m+
(B[m                         // Pop values from the stack in reverse order (last parameter first)
                         let mut param_values = Vec::with_capacity(params.len());
                         for _ in 0..params.len() {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:501:
                             param_values.push(self.stack.pop().unwrap());
                         }
                         param_values.reverse(); // Reverse to match parameter order
[31m-                        
(B[m[32m+
(B[m                         // Store parameters in the function's memory
                         for (param, value) in params.iter().zip(param_values.iter()) {
                             frame.memory.insert(param.clone(), *value);
Diff in /home/matt/dev/nano-cvm/src/vm.rs:508:
                         }
                     }
[31m-                    
(B[m[32m+
(B[m                     // Push the call frame onto the call stack
                     self.call_frames.push(frame);
[31m-                    
(B[m[32m+
(B[m                     // Increment recursion depth
                     self.recursion_depth += 1;
[31m-                    
(B[m[32m+
(B[m                     // Execute the function body
                     self.execute_inner(&body)?;
[31m-                    
(B[m[32m+
(B[m                     // Decrement recursion depth
                     self.recursion_depth -= 1;
[31m-                    
(B[m[32m+
(B[m                     // Pop the call frame and get the return value if there is one
                     let frame = self.call_frames.pop().unwrap();
[31m-                    
(B[m[32m+
(B[m                     // Push the return value onto the stack if there is one
                     if let Some(return_value) = frame.return_value {
                         self.stack.push(return_value);
Diff in /home/matt/dev/nano-cvm/src/vm.rs:529:
                     }
                 }
[31m-                
(B[m[32m+
(B[m                 Op::Return => {
                     // If we're in a function, set the return value
                     if !self.call_frames.is_empty() {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:539:
                             // If the stack is empty, default to 0.0
                             0.0
                         };
[31m-                        
(B[m[32m+
(B[m                         // Store the return value in the current call frame
                         let frame = self.call_frames.last_mut().unwrap();
                         frame.return_value = Some(return_value);
Diff in /home/matt/dev/nano-cvm/src/vm.rs:546:
[31m-                        
(B[m[32m+
(B[m                         // Exit the current function execution
                         break;
                     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:550:
                 }
[31m-                
(B[m[32m+
(B[m                 Op::Nop => {}
[31m-                
(B[m[31m-                Op::Match { value, cases, default } => {
(B[m[32m+
(B[m[32m+                Op::Match {
(B[m[32m+                    value,
(B[m[32m+                    cases,
(B[m[32m+                    default,
(B[m[32m+                } => {
(B[m                     // Execute value operations to get match value
                     if !value.is_empty() {
                         self.execute_inner(value)?;
Diff in /home/matt/dev/nano-cvm/src/vm.rs:558:
                     }
[31m-                    
(B[m[32m+
(B[m                     // Get the value to match
                     let match_value = self.pop_one("Match")?;
[31m-                    
(B[m[32m+
(B[m                     // Find matching case
                     let mut found_match = false;
                     for (case_value, case_ops) in cases {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:569:
                             break;
                         }
                     }
[31m-                    
(B[m[32m+
(B[m                     // If no match found and there's a default block, execute it
                     if !found_match {
                         if let Some(default_block) = default {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:580:
                         }
                     }
                 }
[31m-                
(B[m[32m+
(B[m                 Op::AssertTop(expected) => {
                     let value = self.pop_one("AssertTop")?;
                     if (value - *expected).abs() >= f64::EPSILON {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:590:
                         });
                     }
                 }
[31m-                
(B[m[32m+
(B[m                 Op::AssertMemory { key, expected } => {
[31m-                    let value = self.memory.get(key)
(B[m[32m+                    let value = self
(B[m[32m+                        .memory
(B[m[32m+                        .get(key)
(B[m                         .ok_or_else(|| VMError::VariableNotFound(key.clone()))?;
                     if (value - expected).abs() >= f64::EPSILON {
                         return Err(VMError::AssertionFailed {
Diff in /home/matt/dev/nano-cvm/src/vm.rs:602:
                     }
                 }
             }
[31m-            
(B[m[32m+
(B[m             pc += 1;
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 
Diff in /home/matt/dev/nano-cvm/src/vm.rs:661:
 
         assert_eq!(
             vm.execute(&ops),
[31m-            Err(VMError::StackUnderflow { 
(B[m[31m-                op: "Add".to_string(), 
(B[m[31m-                needed: 2, 
(B[m[31m-                found: 1 
(B[m[32m+            Err(VMError::StackUnderflow {
(B[m[32m+                op: "Add".to_string(),
(B[m[32m+                needed: 2,
(B[m[32m+                found: 1
(B[m             })
         );
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:688:
         let mut vm = VM::new();
         let ops = vec![Op::Load("nonexistent".to_string())];
 
[31m-        assert_eq!(vm.execute(&ops), Err(VMError::VariableNotFound("nonexistent".to_string())));
(B[m[32m+        assert_eq!(
(B[m[32m+            vm.execute(&ops),
(B[m[32m+            Err(VMError::VariableNotFound("nonexistent".to_string()))
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:698:
 
         assert_eq!(
             vm.execute(&ops),
[31m-            Err(VMError::StackUnderflow { 
(B[m[31m-                op: "Store".to_string(), 
(B[m[31m-                needed: 1, 
(B[m[31m-                found: 0 
(B[m[32m+            Err(VMError::StackUnderflow {
(B[m[32m+                op: "Store".to_string(),
(B[m[32m+                needed: 1,
(B[m[32m+                found: 0
(B[m             })
         );
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:729:
     fn test_if_zero_true() {
         let mut vm = VM::new();
         let ops = vec![
[31m-            Op::Push(0.0),  // Condition value is 0.0 (true in this VM)
(B[m[32m+            Op::Push(0.0), // Condition value is 0.0 (true in this VM)
(B[m             Op::If {
                 condition: vec![],
[31m-                then: vec![Op::Push(42.0)],  // Should execute when condition is 0.0
(B[m[32m+                then: vec![Op::Push(42.0)], // Should execute when condition is 0.0
(B[m                 else_: None,
             },
         ];
Diff in /home/matt/dev/nano-cvm/src/vm.rs:739:
 
         assert!(vm.execute(&ops).is_ok());
[31m-        assert_eq!(vm.top(), Some(42.0));  // Then block executed because condition was 0.0 (true)
(B[m[32m+        assert_eq!(vm.top(), Some(42.0)); // Then block executed because condition was 0.0 (true)
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:745:
     fn test_if_zero_false() {
         let mut vm = VM::new();
         let ops = vec![
[31m-            Op::Push(1.0),  // Condition value is non-zero (false in this VM)
(B[m[32m+            Op::Push(1.0), // Condition value is non-zero (false in this VM)
(B[m             Op::If {
                 condition: vec![],
[31m-                then: vec![Op::Push(42.0)],  // Should not execute
(B[m[32m+                then: vec![Op::Push(42.0)], // Should not execute
(B[m                 else_: None,
             },
         ];
Diff in /home/matt/dev/nano-cvm/src/vm.rs:755:
 
         assert!(vm.execute(&ops).is_ok());
[31m-        assert_eq!(vm.top(), Some(1.0));  // Then block not executed, original value remains
(B[m[32m+        assert_eq!(vm.top(), Some(1.0)); // Then block not executed, original value remains
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:768:
 
         assert_eq!(
             vm.execute(&ops),
[31m-            Err(VMError::StackUnderflow { 
(B[m[31m-                op: "If".to_string(), 
(B[m[31m-                needed: 1, 
(B[m[31m-                found: 0 
(B[m[32m+            Err(VMError::StackUnderflow {
(B[m[32m+                op: "If".to_string(),
(B[m[32m+                needed: 1,
(B[m[32m+                found: 0
(B[m             })
         );
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:780:
     fn test_nested_if_zero() {
         let mut vm = VM::new();
         let ops = vec![
[31m-            Op::Push(0.0),  // Initial stack value (true)
(B[m[32m+            Op::Push(0.0), // Initial stack value (true)
(B[m             Op::If {
                 condition: vec![
[31m-                    Op::Push(1.0),  // Push false for outer condition
(B[m[32m+                    Op::Push(1.0), // Push false for outer condition
(B[m                     Op::If {
[31m-                        condition: vec![Op::Push(0.0)],  // Push true for inner condition
(B[m[31m-                        then: vec![Op::Push(42.0)],      // Should run (condition is true/0.0)
(B[m[32m+                        condition: vec![Op::Push(0.0)], // Push true for inner condition
(B[m[32m+                        then: vec![Op::Push(42.0)],     // Should run (condition is true/0.0)
(B[m                         else_: None,
                     },
                 ],
Diff in /home/matt/dev/nano-cvm/src/vm.rs:793:
[31m-                then: vec![Op::Push(24.0)],  // This should run if the condition evaluates to 0.0
(B[m[32m+                then: vec![Op::Push(24.0)], // This should run if the condition evaluates to 0.0
(B[m                 else_: None,
             },
         ];
Diff in /home/matt/dev/nano-cvm/src/vm.rs:797:
 
         assert!(vm.execute(&ops).is_ok());
[31m-        
(B[m[31m-        // The outer condition operation pushes 1.0 and then contains a nested if 
(B[m[31m-        // that leaves 42.0 on the stack. So the condition is 42.0, not 0.0, 
(B[m[32m+
(B[m[32m+        // The outer condition operation pushes 1.0 and then contains a nested if
(B[m[32m+        // that leaves 42.0 on the stack. So the condition is 42.0, not 0.0,
(B[m         // meaning the then block should not run, leaving 42.0 as the final result.
         assert_eq!(vm.top(), Some(42.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:937:
     #[test]
     fn test_negate() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::Negate,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(42.0), Op::Negate];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(-42.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:949:
     #[test]
     fn test_negate_zero() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(0.0),
(B[m[31m-            Op::Negate,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(0.0), Op::Negate];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(0.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:962:
     fn test_negate_empty_stack() {
         let mut vm = VM::new();
         let ops = vec![Op::Negate];
[31m-        
(B[m[31m-        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
(B[m[31m-            op: "Negate".to_string(), 
(B[m[31m-            needed: 1, 
(B[m[31m-            found: 0 
(B[m[31m-        }));
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            vm.execute(&ops),
(B[m[32m+            Err(VMError::StackUnderflow {
(B[m[32m+                op: "Negate".to_string(),
(B[m[32m+                needed: 1,
(B[m[32m+                found: 0
(B[m[32m+            })
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:974:
     fn test_negate_with_arithmetic() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(5.0),
(B[m[31m-            Op::Push(3.0),
(B[m[31m-            Op::Add,
(B[m[31m-            Op::Negate,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(5.0), Op::Push(3.0), Op::Add, Op::Negate];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(-8.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:987:
     #[test]
     fn test_assert_top_success() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::AssertTop(42.0),
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(42.0), Op::AssertTop(42.0)];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
     }
 
Diff in /home/matt/dev/nano-cvm/src/vm.rs:998:
     #[test]
     fn test_assert_top_failure() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::AssertTop(24.0),
(B[m[31m-        ];
(B[m[31m-        
(B[m[31m-        assert_eq!(vm.execute(&ops), Err(VMError::AssertionFailed { 
(B[m[31m-            expected: 24.0, 
(B[m[31m-            found: 42.0 
(B[m[31m-        }));
(B[m[32m+        let ops = vec![Op::Push(42.0), Op::AssertTop(24.0)];
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            vm.execute(&ops),
(B[m[32m+            Err(VMError::AssertionFailed {
(B[m[32m+                expected: 24.0,
(B[m[32m+                found: 42.0
(B[m[32m+            })
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1013:
     fn test_assert_top_empty_stack() {
         let mut vm = VM::new();
         let ops = vec![Op::AssertTop(42.0)];
[31m-        
(B[m[31m-        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
(B[m[31m-            op: "AssertTop".to_string(), 
(B[m[31m-            needed: 1, 
(B[m[31m-            found: 0 
(B[m[31m-        }));
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            vm.execute(&ops),
(B[m[32m+            Err(VMError::StackUnderflow {
(B[m[32m+                op: "AssertTop".to_string(),
(B[m[32m+                needed: 1,
(B[m[32m+                found: 0
(B[m[32m+            })
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1025:
     fn test_assert_top_with_arithmetic() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(5.0),
(B[m[31m-            Op::Push(3.0),
(B[m[31m-            Op::Add,
(B[m[31m-            Op::AssertTop(8.0),
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(5.0), Op::Push(3.0), Op::Add, Op::AssertTop(8.0)];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
     }
 
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1037:
     #[test]
     fn test_dump_stack() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(1.0),
(B[m[31m-            Op::Push(2.0),
(B[m[31m-            Op::Push(3.0),
(B[m[31m-            Op::DumpStack,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(1.0), Op::Push(2.0), Op::Push(3.0), Op::DumpStack];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.stack, vec![1.0, 2.0, 3.0]);
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1058:
             Op::Store("y".to_string()),
             Op::DumpMemory,
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.get_memory("x"), Some(42.0));
         assert_eq!(vm.get_memory("y"), Some(24.0));
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1068:
     fn test_dump_empty_stack() {
         let mut vm = VM::new();
         let ops = vec![Op::DumpStack];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert!(vm.stack.is_empty());
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1077:
     fn test_dump_empty_memory() {
         let mut vm = VM::new();
         let ops = vec![Op::DumpMemory];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert!(vm.memory.is_empty());
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1085:
     #[test]
     fn test_logic_not_true() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::Not,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(42.0), Op::Not];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(0.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1097:
     #[test]
     fn test_logic_not_false() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(0.0),
(B[m[31m-            Op::Not,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(0.0), Op::Not];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(1.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1110:
     fn test_logic_not_empty_stack() {
         let mut vm = VM::new();
         let ops = vec![Op::Not];
[31m-        
(B[m[31m-        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
(B[m[31m-            op: "Not".to_string(), 
(B[m[31m-            needed: 1, 
(B[m[31m-            found: 0 
(B[m[31m-        }));
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            vm.execute(&ops),
(B[m[32m+            Err(VMError::StackUnderflow {
(B[m[32m+                op: "Not".to_string(),
(B[m[32m+                needed: 1,
(B[m[32m+                found: 0
(B[m[32m+            })
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1122:
     fn test_logic_and_true_true() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::Push(24.0),
(B[m[31m-            Op::And,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(42.0), Op::Push(24.0), Op::And];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(1.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1134:
     #[test]
     fn test_logic_and_true_false() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::Push(0.0),
(B[m[31m-            Op::And,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(42.0), Op::Push(0.0), Op::And];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(0.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1147:
     #[test]
     fn test_logic_and_false_true() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(0.0),
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::And,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(0.0), Op::Push(42.0), Op::And];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(0.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1160:
     #[test]
     fn test_logic_and_false_false() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(0.0),
(B[m[31m-            Op::Push(0.0),
(B[m[31m-            Op::And,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(0.0), Op::Push(0.0), Op::And];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(0.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1174:
     fn test_logic_and_stack_underflow() {
         let mut vm = VM::new();
         let ops = vec![Op::Push(42.0), Op::And];
[31m-        
(B[m[31m-        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
(B[m[31m-            op: "And".to_string(), 
(B[m[31m-            needed: 2, 
(B[m[31m-            found: 1 
(B[m[31m-        }));
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            vm.execute(&ops),
(B[m[32m+            Err(VMError::StackUnderflow {
(B[m[32m+                op: "And".to_string(),
(B[m[32m+                needed: 2,
(B[m[32m+                found: 1
(B[m[32m+            })
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1186:
     fn test_logic_or_true_true() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::Push(24.0),
(B[m[31m-            Op::Or,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(42.0), Op::Push(24.0), Op::Or];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(1.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1198:
     #[test]
     fn test_logic_or_true_false() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::Push(0.0),
(B[m[31m-            Op::Or,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(42.0), Op::Push(0.0), Op::Or];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(1.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1211:
     #[test]
     fn test_logic_or_false_true() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(0.0),
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::Or,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(0.0), Op::Push(42.0), Op::Or];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(1.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1224:
     #[test]
     fn test_logic_or_false_false() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(0.0),
(B[m[31m-            Op::Push(0.0),
(B[m[31m-            Op::Or,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(0.0), Op::Push(0.0), Op::Or];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(0.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1238:
     fn test_logic_or_stack_underflow() {
         let mut vm = VM::new();
         let ops = vec![Op::Push(42.0), Op::Or];
[31m-        
(B[m[31m-        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
(B[m[31m-            op: "Or".to_string(), 
(B[m[31m-            needed: 2, 
(B[m[31m-            found: 1 
(B[m[31m-        }));
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            vm.execute(&ops),
(B[m[32m+            Err(VMError::StackUnderflow {
(B[m[32m+                op: "Or".to_string(),
(B[m[32m+                needed: 2,
(B[m[32m+                found: 1
(B[m[32m+            })
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1253:
             Op::Push(5.0),
             Op::Store("counter".to_string()),
             Op::While {
[31m-                condition: vec![
(B[m[31m-                    Op::Load("counter".to_string()),
(B[m[31m-                    Op::Push(0.0),
(B[m[31m-                    Op::Gt,
(B[m[31m-                ],
(B[m[32m+                condition: vec![Op::Load("counter".to_string()), Op::Push(0.0), Op::Gt],
(B[m                 body: vec![
                     Op::Load("counter".to_string()),
                     Op::Push(1.0),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1267:
             },
             Op::Load("counter".to_string()),
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(0.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1275:
     #[test]
     fn test_while_empty_condition() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::While {
(B[m[31m-                condition: vec![],
(B[m[31m-                body: vec![Op::Push(1.0)],
(B[m[31m-            }
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::While {
(B[m[32m+            condition: vec![],
(B[m[32m+            body: vec![Op::Push(1.0)],
(B[m[32m+        }];
(B[m[32m+
(B[m         assert_eq!(
             vm.execute(&ops),
[31m-            Err(VMError::InvalidCondition("While condition block cannot be empty".to_string()))
(B[m[32m+            Err(VMError::InvalidCondition(
(B[m[32m+                "While condition block cannot be empty".to_string()
(B[m[32m+            ))
(B[m         );
     }
 
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1299:
                 body: vec![Op::Push(42.0)],
             },
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.get_memory("counter"), Some(0.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1307:
     #[test]
     fn test_stack_dup() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::Dup,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(42.0), Op::Dup];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.stack, vec![42.0, 42.0]);
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1320:
     fn test_stack_dup_empty() {
         let mut vm = VM::new();
         let ops = vec![Op::Dup];
[31m-        
(B[m[31m-        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
(B[m[31m-            op: "Dup".to_string(), 
(B[m[31m-            needed: 1, 
(B[m[31m-            found: 0 
(B[m[31m-        }));
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            vm.execute(&ops),
(B[m[32m+            Err(VMError::StackUnderflow {
(B[m[32m+                op: "Dup".to_string(),
(B[m[32m+                needed: 1,
(B[m[32m+                found: 0
(B[m[32m+            })
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1332:
     fn test_stack_swap() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::Push(24.0),
(B[m[31m-            Op::Swap,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(42.0), Op::Push(24.0), Op::Swap];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.stack, vec![24.0, 42.0]);
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1345:
     fn test_stack_swap_underflow() {
         let mut vm = VM::new();
         let ops = vec![Op::Push(42.0), Op::Swap];
[31m-        
(B[m[31m-        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
(B[m[31m-            op: "Swap".to_string(), 
(B[m[31m-            needed: 2, 
(B[m[31m-            found: 1 
(B[m[31m-        }));
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            vm.execute(&ops),
(B[m[32m+            Err(VMError::StackUnderflow {
(B[m[32m+                op: "Swap".to_string(),
(B[m[32m+                needed: 2,
(B[m[32m+                found: 1
(B[m[32m+            })
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1357:
     fn test_stack_over() {
         let mut vm = VM::new();
[31m-        let ops = vec![
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::Push(24.0),
(B[m[31m-            Op::Over,
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(42.0), Op::Push(24.0), Op::Over];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.stack, vec![42.0, 24.0, 42.0]);
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1370:
     fn test_stack_over_underflow() {
         let mut vm = VM::new();
         let ops = vec![Op::Push(42.0), Op::Over];
[31m-        
(B[m[31m-        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
(B[m[31m-            op: "Over".to_string(), 
(B[m[31m-            needed: 2, 
(B[m[31m-            found: 1 
(B[m[31m-        }));
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            vm.execute(&ops),
(B[m[32m+            Err(VMError::StackUnderflow {
(B[m[32m+                op: "Over".to_string(),
(B[m[32m+                needed: 2,
(B[m[32m+                found: 1
(B[m[32m+            })
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1385:
             Op::Push(1.0),
             Op::Push(2.0),
             Op::Push(3.0),
[31m-            Op::Dup,   // Stack: [1, 2, 3, 3]
(B[m[31m-            Op::Swap,  // Stack: [1, 2, 3, 3] -> [1, 2, 3, 3]
(B[m[31m-            Op::Over,  // Stack: [1, 2, 3, 3, 3]
(B[m[32m+            Op::Dup,  // Stack: [1, 2, 3, 3]
(B[m[32m+            Op::Swap, // Stack: [1, 2, 3, 3] -> [1, 2, 3, 3]
(B[m[32m+            Op::Over, // Stack: [1, 2, 3, 3, 3]
(B[m         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.stack, vec![1.0, 2.0, 3.0, 3.0, 3.0]);
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1401:
             Op::Def {
                 name: "double".to_string(),
                 params: vec![],
[31m-                body: vec![
(B[m[31m-                    Op::Push(2.0),
(B[m[31m-                    Op::Mul,
(B[m[31m-                ],
(B[m[32m+                body: vec![Op::Push(2.0), Op::Mul],
(B[m             },
             Op::Push(21.0),
             Op::Call("double".to_string()),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1411:
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(42.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1418:
     fn test_function_not_found() {
         let mut vm = VM::new();
         let ops = vec![Op::Call("nonexistent".to_string())];
[31m-        
(B[m[31m-        assert_eq!(vm.execute(&ops), Err(VMError::FunctionNotFound("nonexistent".to_string())));
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            vm.execute(&ops),
(B[m[32m+            Err(VMError::FunctionNotFound("nonexistent".to_string()))
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1429:
             Op::Def {
                 name: "add_one".to_string(),
                 params: vec![],
[31m-                body: vec![
(B[m[31m-                    Op::Push(1.0),
(B[m[31m-                    Op::Add,
(B[m[31m-                    Op::Return,
(B[m[31m-                ],
(B[m[32m+                body: vec![Op::Push(1.0), Op::Add, Op::Return],
(B[m             },
             Op::Push(41.0),
             Op::Call("add_one".to_string()),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1440:
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(42.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1459:
             Op::Push(42.0),
             Op::Call("store_and_load".to_string()),
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(42.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1472:
                 name: "countdown".to_string(),
                 params: vec![],
                 body: vec![
[31m-                    Op::Dup,  // Duplicate the value for comparison
(B[m[32m+                    Op::Dup, // Duplicate the value for comparison
(B[m                     Op::Push(0.0),
[31m-                    Op::Eq,   // Will push 1.0 if n==0, 0.0 otherwise
(B[m[32m+                    Op::Eq, // Will push 1.0 if n==0, 0.0 otherwise
(B[m                     Op::If {
                         condition: vec![],
                         then: vec![
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1481:
                             // Already 0, just return
[31m-                            Op::Push(0.0),  // Explicitly push 0 for the result
(B[m[32m+                            Op::Push(0.0), // Explicitly push 0 for the result
(B[m                         ],
                         else_: Some(vec![
                             // n > 0, so decrement and recurse
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1486:
                             Op::Push(1.0),
[31m-                            Op::Sub,      // Decrement n
(B[m[31m-                            Op::Call("countdown".to_string()),  // Recursive call
(B[m[32m+                            Op::Sub,                           // Decrement n
(B[m[32m+                            Op::Call("countdown".to_string()), // Recursive call
(B[m                         ]),
                     },
                 ],
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1492:
             },
[31m-            Op::Push(3.0),  // Use a smaller number to avoid stack overflow
(B[m[32m+            Op::Push(3.0), // Use a smaller number to avoid stack overflow
(B[m             Op::Call("countdown".to_string()),
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(0.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1505:
             Op::Def {
                 name: "push_and_pop".to_string(),
                 params: vec![],
[31m-                body: vec![
(B[m[31m-                    Op::Push(42.0),
(B[m[31m-                    Op::Pop,
(B[m[31m-                    Op::Return,
(B[m[31m-                ],
(B[m[32m+                body: vec![Op::Push(42.0), Op::Pop, Op::Return],
(B[m             },
             Op::Push(24.0),
             Op::Call("push_and_pop".to_string()),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1516:
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(24.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1530:
                 params: vec![],
                 body: vec![
                     Op::Push(24.0),
[31m-                    Op::Store("x".to_string()),  // This should update the function's x, not global x
(B[m[32m+                    Op::Store("x".to_string()), // This should update the function's x, not global x
(B[m                     Op::Return,
                 ],
             },
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1537:
             Op::Call("store_value".to_string()),
             // No return value, so we need to load x to verify it's unchanged
[31m-            Op::Load("x".to_string()),  // Should be 42.0, not 24.0
(B[m[32m+            Op::Load("x".to_string()), // Should be 42.0, not 24.0
(B[m         ];
 
         assert!(vm.execute(&ops).is_ok());
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1543:
[31m-        assert_eq!(vm.top(), Some(42.0));  // Global x should be 42.0
(B[m[32m+        assert_eq!(vm.top(), Some(42.0)); // Global x should be 42.0
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1554:
                     Op::Load("x".to_string()),
                     Op::Push(5.0),
                     Op::Add,
[31m-                    Op::Store("x".to_string()),  // Should modify the local x, not global x
(B[m[31m-                    Op::Load("x".to_string()),   // Should get the modified local x
(B[m[32m+                    Op::Store("x".to_string()), // Should modify the local x, not global x
(B[m[32m+                    Op::Load("x".to_string()),  // Should get the modified local x
(B[m                     Op::Return,
                 ],
             },
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1562:
             Op::Push(10.0),
[31m-            Op::Store("x".to_string()),  // Global x = 10
(B[m[31m-            Op::Push(20.0),              // Parameter value
(B[m[31m-            Op::Call("add_to_param".to_string()),  // Should return 25 (20+5)
(B[m[31m-            Op::Load("x".to_string()),   // Should still be 10 (global x unchanged)
(B[m[32m+            Op::Store("x".to_string()),           // Global x = 10
(B[m[32m+            Op::Push(20.0),                       // Parameter value
(B[m[32m+            Op::Call("add_to_param".to_string()), // Should return 25 (20+5)
(B[m[32m+            Op::Load("x".to_string()),            // Should still be 10 (global x unchanged)
(B[m         ];
[31m-         
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.stack.len(), 2);
[31m-        assert_eq!(vm.stack[0], 25.0);  // Return value from function (parameter + 5)
(B[m[31m-        assert_eq!(vm.stack[1], 10.0);  // Global x value unchanged
(B[m[32m+        assert_eq!(vm.stack[0], 25.0); // Return value from function (parameter + 5)
(B[m[32m+        assert_eq!(vm.stack[1], 10.0); // Global x value unchanged
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1579:
             Op::Def {
                 name: "inner".to_string(),
                 params: vec![],
[31m-                body: vec![
(B[m[31m-                    Op::Push(2.0),
(B[m[31m-                    Op::Mul,
(B[m[31m-                    Op::Return,
(B[m[31m-                ],
(B[m[32m+                body: vec![Op::Push(2.0), Op::Mul, Op::Return],
(B[m             },
             Op::Def {
                 name: "outer".to_string(),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1598:
             Op::Push(7.0),
             Op::Call("outer".to_string()),
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(42.0)); // 7 * 2 * 3
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1621:
             Op::Push(22.0),
             Op::Call("add".to_string()),
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(42.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1643:
             Op::Push(42.0),
             Op::Call("add".to_string()),
         ];
[31m-         
(B[m[31m-        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
(B[m[31m-            op: "Call to function 'add'".to_string(), 
(B[m[31m-            needed: 2, 
(B[m[31m-            found: 1 
(B[m[31m-        }));
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            vm.execute(&ops),
(B[m[32m+            Err(VMError::StackUnderflow {
(B[m[32m+                op: "Call to function 'add'".to_string(),
(B[m[32m+                needed: 2,
(B[m[32m+                found: 1
(B[m[32m+            })
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1659:
                 name: "countdown".to_string(),
                 params: vec!["n".to_string()],
                 body: vec![
[31m-                    Op::Load("n".to_string()),  // Load the parameter
(B[m[32m+                    Op::Load("n".to_string()), // Load the parameter
(B[m                     Op::Push(0.0),
[31m-                    Op::Eq,   // Will push 1.0 if n==0, 0.0 otherwise
(B[m[32m+                    Op::Eq, // Will push 1.0 if n==0, 0.0 otherwise
(B[m                     Op::If {
                         condition: vec![],
                         then: vec![
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1668:
[31m-                            Op::Push(0.0),  // Return 0 when n==0
(B[m[32m+                            Op::Push(0.0), // Return 0 when n==0
(B[m                         ],
                         else_: Some(vec![
                             // n > 0, so decrement and recurse
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1672:
                             Op::Load("n".to_string()),
                             Op::Push(1.0),
[31m-                            Op::Sub,                       // Compute n-1
(B[m[31m-                            Op::Call("countdown".to_string()),  // Call countdown(n-1)
(B[m[32m+                            Op::Sub,                           // Compute n-1
(B[m[32m+                            Op::Call("countdown".to_string()), // Call countdown(n-1)
(B[m                         ]),
                     },
                     // Return (implicit)
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1681:
             Op::Push(5.0),
             Op::Call("countdown".to_string()),
         ];
[31m-         
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(0.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1714:
             Op::Push(7.0),
             Op::Call("outer".to_string()),
         ];
[31m-         
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(42.0)); // 7 * 2 * 3
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1744:
             },
             Op::Load("counter".to_string()),
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(5.0)); // Loop should break at counter = 5
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1751:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_continue_in_loop() {
         let mut vm = VM::new();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1764:
                     Op::Push(1.0),
                     Op::Add,
                     Op::Store("counter".to_string()),
[31m-                    
(B[m                     // Skip odd numbers
                     Op::Load("counter".to_string()),
                     Op::Push(2.0),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1777:
                         then: vec![Op::Continue],
                         else_: None,
                     },
[31m-                    
(B[m                     // Add even numbers to sum
                     Op::Load("sum".to_string()),
                     Op::Load("counter".to_string()),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1787:
             },
             Op::Load("sum".to_string()),
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(30.0)); // Sum of even numbers from 2 to 10 = 2+4+6+8+10 = 30
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1794:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_break_in_while() {
         let mut vm = VM::new();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1798:
[31m-        
(B[m[32m+
(B[m         // Create a simpler test case that's more likely to work
         let ops = vec![
             Op::Push(0.0),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1802:
             Op::Store("counter".to_string()),
             Op::While {
                 condition: vec![
[31m-                    Op::Push(0.0),  // True condition (0.0)
(B[m[32m+                    Op::Push(0.0), // True condition (0.0)
(B[m                 ],
                 body: vec![
                     // Increment counter
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1810:
                     Op::Push(1.0),
                     Op::Add,
                     Op::Store("counter".to_string()),
[31m-                    
(B[m                     // If counter == 5, break
                     Op::Load("counter".to_string()),
                     Op::Push(5.0),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1825:
             // Load the counter to verify
             Op::Load("counter".to_string()),
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(5.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1832:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_continue_in_while() {
         let mut vm = VM::new();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1839:
             Op::Push(0.0),
             Op::Store("counter".to_string()),
             Op::While {
[31m-                condition: vec![
(B[m[31m-                    Op::Load("counter".to_string()),
(B[m[31m-                    Op::Push(10.0),
(B[m[31m-                    Op::Lt,
(B[m[31m-                ],
(B[m[32m+                condition: vec![Op::Load("counter".to_string()), Op::Push(10.0), Op::Lt],
(B[m                 body: vec![
                     Op::Load("counter".to_string()),
                     Op::Push(1.0),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1850:
                     Op::Add,
                     Op::Store("counter".to_string()),
[31m-                    
(B[m                     // Skip odd numbers
                     Op::Load("counter".to_string()),
                     Op::Push(2.0),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1862:
                         then: vec![Op::Continue],
                         else_: None,
                     },
[31m-                    
(B[m                     // Add even numbers to sum
                     Op::Load("sum".to_string()),
                     Op::Load("counter".to_string()),
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1872:
             },
             Op::Load("sum".to_string()),
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(30.0)); // Sum of even numbers from 2 to 10 = 2+4+6+8+10 = 30
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1879:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_match_statement() {
         let mut vm = VM::new();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1892:
                 default: Some(vec![Op::Push(0.0)]),
             },
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(20.0)); // Should match case 2
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1899:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_match_with_default() {
         let mut vm = VM::new();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1912:
                 default: Some(vec![Op::Push(999.0)]),
             },
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(999.0)); // Should execute default
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1919:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_match_no_default() {
         let mut vm = VM::new();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1932:
                 default: None,
             },
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(5.0)); // Should keep original value
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1939:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_match_with_computed_value() {
         let mut vm = VM::new();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1943:
[31m-        let ops = vec![
(B[m[31m-            Op::Match {
(B[m[31m-                value: vec![
(B[m[31m-                    Op::Push(1.0),
(B[m[31m-                    Op::Push(2.0),
(B[m[31m-                    Op::Add,
(B[m[31m-                ],
(B[m[31m-                cases: vec![
(B[m[31m-                    (1.0, vec![Op::Push(10.0)]),
(B[m[31m-                    (3.0, vec![Op::Push(30.0)]),
(B[m[31m-                    (4.0, vec![Op::Push(40.0)]),
(B[m[31m-                ],
(B[m[31m-                default: Some(vec![Op::Push(999.0)]),
(B[m[31m-            },
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Match {
(B[m[32m+            value: vec![Op::Push(1.0), Op::Push(2.0), Op::Add],
(B[m[32m+            cases: vec![
(B[m[32m+                (1.0, vec![Op::Push(10.0)]),
(B[m[32m+                (3.0, vec![Op::Push(30.0)]),
(B[m[32m+                (4.0, vec![Op::Push(40.0)]),
(B[m[32m+            ],
(B[m[32m+            default: Some(vec![Op::Push(999.0)]),
(B[m[32m+        }];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(30.0)); // 1+2=3, should match case 3
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1962:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_emit_event() {
         let mut vm = VM::new();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1970:
             },
             Op::Push(42.0), // Just to verify execution continues
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.top(), Some(42.0));
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1977:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_assert_equal_stack_success() {
         let mut vm = VM::new();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1984:
             Op::Push(42.0),
             Op::AssertEqualStack { depth: 3 },
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_ok());
         assert_eq!(vm.stack, vec![42.0, 42.0, 42.0]);
     }
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1991:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_assert_equal_stack_failure() {
         let mut vm = VM::new();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:1998:
             Op::Push(42.0),
             Op::AssertEqualStack { depth: 3 },
         ];
[31m-        
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_err());
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_assert_equal_stack_underflow() {
         let mut vm = VM::new();
Diff in /home/matt/dev/nano-cvm/src/vm.rs:2008:
[31m-        let ops = vec![
(B[m[31m-            Op::Push(42.0),
(B[m[31m-            Op::AssertEqualStack { depth: 3 },
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let ops = vec![Op::Push(42.0), Op::AssertEqualStack { depth: 3 }];
(B[m[32m+
(B[m         assert!(vm.execute(&ops).is_err());
     }
 }
[1;38;5;9merror[internal][0m: [1mleft behind trailing whitespace[0m
   [1;38;5;12m-->[0m /home/matt/dev/nano-cvm/src/vm.rs:378:378:36
[1;38;5;12m    |[0m
[1;38;5;12m378 |[0m                         self.stack, 
[1;38;5;12m    |[0m[1;38;5;9m                                    ^[0m
[1;38;5;12m    |[0m

[1;38;5;9merror[internal][0m: [1mleft behind trailing whitespace[0m
   [1;38;5;12m-->[0m /home/matt/dev/nano-cvm/src/vm.rs:379:379:37
[1;38;5;12m    |[0m
[1;38;5;12m379 |[0m                         self.memory, 
[1;38;5;12m    |[0m[1;38;5;9m                                     ^[0m
[1;38;5;12m    |[0m

[1;38;5;11mwarning[0m: [1mrustfmt has failed to format. See previous 2 errors.[0m

Diff in /home/matt/dev/nano-cvm/tests/integration.rs:1:
[32m+use nano_cvm::{Op, VM};
(B[m[32m+use serde_json;
(B[m use std::fs;
 use std::path::Path;
[31m-use serde_json;
(B[m[31m-use nano_cvm::{Op, VM};
(B[m 
 #[test]
 fn test_program_json_runs_correctly() -> Result<(), Box<dyn std::error::Error>> {
Diff in /home/matt/dev/nano-cvm/tests/integration.rs:32:
         Op::Push(2.0),
         Op::Add,
         Op::Match {
[31m-            value: vec![],  // Empty - use value on stack
(B[m[32m+            value: vec![], // Empty - use value on stack
(B[m             cases: vec![
[31m-                (3.0, vec![Op::Push(42.0)]),  // Should match 3
(B[m[32m+                (3.0, vec![Op::Push(42.0)]), // Should match 3
(B[m                 (4.0, vec![Op::Push(24.0)]),
             ],
             default: Some(vec![Op::Push(0.0)]),
Diff in /home/matt/dev/nano-cvm/tests/integration.rs:41:
         },
[31m-        
(B[m         // Test AssertEqualStack
         Op::Dup,
         Op::Dup,
Diff in /home/matt/dev/nano-cvm/tests/integration.rs:46:
         Op::AssertEqualStack { depth: 3 },
[31m-        
(B[m         // Test EmitEvent
[31m-        Op::EmitEvent { 
(B[m[31m-            category: "test".to_string(), 
(B[m[31m-            message: "governance operations test".to_string() 
(B[m[32m+        Op::EmitEvent {
(B[m[32m+            category: "test".to_string(),
(B[m[32m+            message: "governance operations test".to_string(),
(B[m         },
[31m-        
(B[m         // Test Break in Loop
         Op::Push(0.0),
         Op::Store("counter".to_string()),
Diff in /home/matt/dev/nano-cvm/tests/integration.rs:72:
             ],
         },
         Op::Load("counter".to_string()),
[31m-        
(B[m         // Test Continue in While
         Op::Push(0.0),
         Op::Store("sum".to_string()),
Diff in /home/matt/dev/nano-cvm/tests/integration.rs:79:
         Op::Push(0.0),
         Op::Store("i".to_string()),
         Op::While {
[31m-            condition: vec![
(B[m[31m-                Op::Load("i".to_string()),
(B[m[31m-                Op::Push(5.0),
(B[m[31m-                Op::Lt,
(B[m[31m-            ],
(B[m[32m+            condition: vec![Op::Load("i".to_string()), Op::Push(5.0), Op::Lt],
(B[m             body: vec![
                 Op::Load("i".to_string()),
                 Op::Push(1.0),
Diff in /home/matt/dev/nano-cvm/tests/integration.rs:90:
[31m-                Op::Add, 
(B[m[32m+                Op::Add,
(B[m                 Op::Store("i".to_string()),
[31m-                
(B[m                 // Skip odd numbers
                 Op::Load("i".to_string()),
                 Op::Push(2.0),
Diff in /home/matt/dev/nano-cvm/tests/integration.rs:102:
                     then: vec![Op::Continue],
                     else_: None,
                 },
[31m-                
(B[m                 // Add even numbers
                 Op::Load("sum".to_string()),
                 Op::Load("i".to_string()),
Diff in /home/matt/dev/nano-cvm/tests/integration.rs:120:
     // Verify results
     let stack = vm.get_stack();
     assert_eq!(stack.len(), 3);
[31m-    assert_eq!(stack[0], 42.0);  // Result of Match operation
(B[m[31m-    assert_eq!(stack[1], 5.0);   // Result of Break test
(B[m[31m-    assert_eq!(stack[2], 6.0);   // Result of Continue test (sum of 2+4)
(B[m[32m+    assert_eq!(stack[0], 42.0); // Result of Match operation
(B[m[32m+    assert_eq!(stack[1], 5.0); // Result of Break test
(B[m[32m+    assert_eq!(stack[2], 6.0); // Result of Continue test (sum of 2+4)
(B[m 
     // Verify memory
     assert_eq!(vm.get_memory("counter"), Some(5.0));
Diff in /home/matt/dev/nano-cvm/tests/integration.rs:130:
     assert_eq!(vm.get_memory("i"), Some(5.0));
 
     Ok(())
[31m-} 
(B[m[32m+}
(B[m[32m+
(B[mmake: *** [Makefile:13: fmt] Error 1
